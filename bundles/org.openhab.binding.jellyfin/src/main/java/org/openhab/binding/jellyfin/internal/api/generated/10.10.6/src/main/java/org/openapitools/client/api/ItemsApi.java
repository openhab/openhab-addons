/*
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.10.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;

import org.openapitools.client.model.BaseItemDtoQueryResult;
import org.openapitools.client.model.BaseItemKind;
import org.openapitools.client.model.ImageType;
import org.openapitools.client.model.ItemFields;
import org.openapitools.client.model.ItemFilter;
import org.openapitools.client.model.ItemSortBy;
import org.openapitools.client.model.LocationType;
import org.openapitools.client.model.MediaType;
import java.time.OffsetDateTime;
import org.openapitools.client.model.ProblemDetails;
import org.openapitools.client.model.SeriesStatus;
import org.openapitools.client.model.SortOrder;
import java.util.UUID;
import org.openapitools.client.model.UpdateUserItemDataDto;
import org.openapitools.client.model.UserItemDataDto;
import org.openapitools.client.model.VideoType;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-02-28T21:48:58.939457991Z[Etc/UTC]", comments = "Generator version: 7.12.0")
public class ItemsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public ItemsApi() {
    this(Configuration.getDefaultApiClient());
  }

  public ItemsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Get Item User Data.
   * 
   * @param itemId The item id. (required)
   * @param userId The user id. (optional)
   * @return UserItemDataDto
   * @throws ApiException if fails to make API call
   */
  public UserItemDataDto getItemUserData(UUID itemId, UUID userId) throws ApiException {
    ApiResponse<UserItemDataDto> localVarResponse = getItemUserDataWithHttpInfo(itemId, userId);
    return localVarResponse.getData();
  }

  /**
   * Get Item User Data.
   * 
   * @param itemId The item id. (required)
   * @param userId The user id. (optional)
   * @return ApiResponse&lt;UserItemDataDto&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UserItemDataDto> getItemUserDataWithHttpInfo(UUID itemId, UUID userId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getItemUserDataRequestBuilder(itemId, userId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getItemUserData", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<UserItemDataDto>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<UserItemDataDto>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<UserItemDataDto>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getItemUserDataRequestBuilder(UUID itemId, UUID userId) throws ApiException {
    // verify the required parameter 'itemId' is set
    if (itemId == null) {
      throw new ApiException(400, "Missing the required parameter 'itemId' when calling getItemUserData");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/UserItems/{itemId}/UserData"
        .replace("{itemId}", ApiClient.urlEncode(itemId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "userId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("userId", userId));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json, application/json; profile=CamelCase, application/json; profile=PascalCase");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Gets items based on a query.
   * 
   * @param userId The user id supplied as query parameter; this is required when not using an API key. (optional)
   * @param maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)
   * @param hasThemeSong Optional filter by items with theme songs. (optional)
   * @param hasThemeVideo Optional filter by items with theme videos. (optional)
   * @param hasSubtitles Optional filter by items with subtitles. (optional)
   * @param hasSpecialFeature Optional filter by items with special features. (optional)
   * @param hasTrailer Optional filter by items with trailers. (optional)
   * @param adjacentTo Optional. Return items that are siblings of a supplied item. (optional)
   * @param indexNumber Optional filter by index number. (optional)
   * @param parentIndexNumber Optional filter by parent index number. (optional)
   * @param hasParentalRating Optional filter by items that have or do not have a parental rating. (optional)
   * @param isHd Optional filter by items that are HD or not. (optional)
   * @param is4K Optional filter by items that are 4K or not. (optional)
   * @param locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited. (optional)
   * @param excludeLocationTypes Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited. (optional)
   * @param isMissing Optional filter by items that are missing episodes or not. (optional)
   * @param isUnaired Optional filter by items that are unaired episodes or not. (optional)
   * @param minCommunityRating Optional filter by minimum community rating. (optional)
   * @param minCriticRating Optional filter by minimum critic rating. (optional)
   * @param minPremiereDate Optional. The minimum premiere date. Format &#x3D; ISO. (optional)
   * @param minDateLastSaved Optional. The minimum last saved date. Format &#x3D; ISO. (optional)
   * @param minDateLastSavedForUser Optional. The minimum last saved date for the current user. Format &#x3D; ISO. (optional)
   * @param maxPremiereDate Optional. The maximum premiere date. Format &#x3D; ISO. (optional)
   * @param hasOverview Optional filter by items that have an overview or not. (optional)
   * @param hasImdbId Optional filter by items that have an IMDb id or not. (optional)
   * @param hasTmdbId Optional filter by items that have a TMDb id or not. (optional)
   * @param hasTvdbId Optional filter by items that have a TVDb id or not. (optional)
   * @param isMovie Optional filter for live tv movies. (optional)
   * @param isSeries Optional filter for live tv series. (optional)
   * @param isNews Optional filter for live tv news. (optional)
   * @param isKids Optional filter for live tv kids. (optional)
   * @param isSports Optional filter for live tv sports. (optional)
   * @param excludeItemIds Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited. (optional)
   * @param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
   * @param limit Optional. The maximum number of records to return. (optional)
   * @param recursive When searching within folders, this determines whether or not the search will be recursive. true/false. (optional)
   * @param searchTerm Optional. Filter based on a search term. (optional)
   * @param sortOrder Sort Order - Ascending, Descending. (optional)
   * @param parentId Specify this to localize the search to a specific item or folder. Omit to use the root. (optional)
   * @param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines. (optional)
   * @param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. (optional)
   * @param includeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited. (optional)
   * @param filters Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes. (optional)
   * @param isFavorite Optional filter by items that are marked as favorite, or not. (optional)
   * @param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited. (optional)
   * @param imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)
   * @param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime. (optional)
   * @param isPlayed Optional filter by items that are played, or not. (optional)
   * @param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited. (optional)
   * @param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited. (optional)
   * @param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited. (optional)
   * @param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited. (optional)
   * @param enableUserData Optional, include user data. (optional)
   * @param imageTypeLimit Optional, the max number of images to return, per image type. (optional)
   * @param enableImageTypes Optional. The image types to include in the output. (optional)
   * @param person Optional. If specified, results will be filtered to include only those containing the specified person. (optional)
   * @param personIds Optional. If specified, results will be filtered to include only those containing the specified person id. (optional)
   * @param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited. (optional)
   * @param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited. (optional)
   * @param artists Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited. (optional)
   * @param excludeArtistIds Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited. (optional)
   * @param artistIds Optional. If specified, results will be filtered to include only those containing the specified artist id. (optional)
   * @param albumArtistIds Optional. If specified, results will be filtered to include only those containing the specified album artist id. (optional)
   * @param contributingArtistIds Optional. If specified, results will be filtered to include only those containing the specified contributing artist id. (optional)
   * @param albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited. (optional)
   * @param albumIds Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited. (optional)
   * @param ids Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited. (optional)
   * @param videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited. (optional)
   * @param minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)
   * @param isLocked Optional filter by items that are locked. (optional)
   * @param isPlaceHolder Optional filter by items that are placeholders. (optional)
   * @param hasOfficialRating Optional filter by items that have official ratings. (optional)
   * @param collapseBoxSetItems Whether or not to hide items behind their boxsets. (optional)
   * @param minWidth Optional. Filter by the minimum width of the item. (optional)
   * @param minHeight Optional. Filter by the minimum height of the item. (optional)
   * @param maxWidth Optional. Filter by the maximum width of the item. (optional)
   * @param maxHeight Optional. Filter by the maximum height of the item. (optional)
   * @param is3D Optional filter by items that are 3D, or not. (optional)
   * @param seriesStatus Optional filter by Series Status. Allows multiple, comma delimited. (optional)
   * @param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string. (optional)
   * @param nameStartsWith Optional filter by items whose name is sorted equally than a given input string. (optional)
   * @param nameLessThan Optional filter by items whose name is equally or lesser than a given input string. (optional)
   * @param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited. (optional)
   * @param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited. (optional)
   * @param enableTotalRecordCount Optional. Enable the total record count. (optional, default to true)
   * @param enableImages Optional, include image information in output. (optional, default to true)
   * @return BaseItemDtoQueryResult
   * @throws ApiException if fails to make API call
   */
  public BaseItemDtoQueryResult getItems(UUID userId, String maxOfficialRating, Boolean hasThemeSong, Boolean hasThemeVideo, Boolean hasSubtitles, Boolean hasSpecialFeature, Boolean hasTrailer, UUID adjacentTo, Integer indexNumber, Integer parentIndexNumber, Boolean hasParentalRating, Boolean isHd, Boolean is4K, List<LocationType> locationTypes, List<LocationType> excludeLocationTypes, Boolean isMissing, Boolean isUnaired, Double minCommunityRating, Double minCriticRating, OffsetDateTime minPremiereDate, OffsetDateTime minDateLastSaved, OffsetDateTime minDateLastSavedForUser, OffsetDateTime maxPremiereDate, Boolean hasOverview, Boolean hasImdbId, Boolean hasTmdbId, Boolean hasTvdbId, Boolean isMovie, Boolean isSeries, Boolean isNews, Boolean isKids, Boolean isSports, List<UUID> excludeItemIds, Integer startIndex, Integer limit, Boolean recursive, String searchTerm, List<SortOrder> sortOrder, UUID parentId, List<ItemFields> fields, List<BaseItemKind> excludeItemTypes, List<BaseItemKind> includeItemTypes, List<ItemFilter> filters, Boolean isFavorite, List<MediaType> mediaTypes, List<ImageType> imageTypes, List<ItemSortBy> sortBy, Boolean isPlayed, List<String> genres, List<String> officialRatings, List<String> tags, List<Integer> years, Boolean enableUserData, Integer imageTypeLimit, List<ImageType> enableImageTypes, String person, List<UUID> personIds, List<String> personTypes, List<String> studios, List<String> artists, List<UUID> excludeArtistIds, List<UUID> artistIds, List<UUID> albumArtistIds, List<UUID> contributingArtistIds, List<String> albums, List<UUID> albumIds, List<UUID> ids, List<VideoType> videoTypes, String minOfficialRating, Boolean isLocked, Boolean isPlaceHolder, Boolean hasOfficialRating, Boolean collapseBoxSetItems, Integer minWidth, Integer minHeight, Integer maxWidth, Integer maxHeight, Boolean is3D, List<SeriesStatus> seriesStatus, String nameStartsWithOrGreater, String nameStartsWith, String nameLessThan, List<UUID> studioIds, List<UUID> genreIds, Boolean enableTotalRecordCount, Boolean enableImages) throws ApiException {
    ApiResponse<BaseItemDtoQueryResult> localVarResponse = getItemsWithHttpInfo(userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, indexNumber, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, isMovie, isSeries, isNews, isKids, isSports, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages);
    return localVarResponse.getData();
  }

  /**
   * Gets items based on a query.
   * 
   * @param userId The user id supplied as query parameter; this is required when not using an API key. (optional)
   * @param maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). (optional)
   * @param hasThemeSong Optional filter by items with theme songs. (optional)
   * @param hasThemeVideo Optional filter by items with theme videos. (optional)
   * @param hasSubtitles Optional filter by items with subtitles. (optional)
   * @param hasSpecialFeature Optional filter by items with special features. (optional)
   * @param hasTrailer Optional filter by items with trailers. (optional)
   * @param adjacentTo Optional. Return items that are siblings of a supplied item. (optional)
   * @param indexNumber Optional filter by index number. (optional)
   * @param parentIndexNumber Optional filter by parent index number. (optional)
   * @param hasParentalRating Optional filter by items that have or do not have a parental rating. (optional)
   * @param isHd Optional filter by items that are HD or not. (optional)
   * @param is4K Optional filter by items that are 4K or not. (optional)
   * @param locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited. (optional)
   * @param excludeLocationTypes Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited. (optional)
   * @param isMissing Optional filter by items that are missing episodes or not. (optional)
   * @param isUnaired Optional filter by items that are unaired episodes or not. (optional)
   * @param minCommunityRating Optional filter by minimum community rating. (optional)
   * @param minCriticRating Optional filter by minimum critic rating. (optional)
   * @param minPremiereDate Optional. The minimum premiere date. Format &#x3D; ISO. (optional)
   * @param minDateLastSaved Optional. The minimum last saved date. Format &#x3D; ISO. (optional)
   * @param minDateLastSavedForUser Optional. The minimum last saved date for the current user. Format &#x3D; ISO. (optional)
   * @param maxPremiereDate Optional. The maximum premiere date. Format &#x3D; ISO. (optional)
   * @param hasOverview Optional filter by items that have an overview or not. (optional)
   * @param hasImdbId Optional filter by items that have an IMDb id or not. (optional)
   * @param hasTmdbId Optional filter by items that have a TMDb id or not. (optional)
   * @param hasTvdbId Optional filter by items that have a TVDb id or not. (optional)
   * @param isMovie Optional filter for live tv movies. (optional)
   * @param isSeries Optional filter for live tv series. (optional)
   * @param isNews Optional filter for live tv news. (optional)
   * @param isKids Optional filter for live tv kids. (optional)
   * @param isSports Optional filter for live tv sports. (optional)
   * @param excludeItemIds Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited. (optional)
   * @param startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results. (optional)
   * @param limit Optional. The maximum number of records to return. (optional)
   * @param recursive When searching within folders, this determines whether or not the search will be recursive. true/false. (optional)
   * @param searchTerm Optional. Filter based on a search term. (optional)
   * @param sortOrder Sort Order - Ascending, Descending. (optional)
   * @param parentId Specify this to localize the search to a specific item or folder. Omit to use the root. (optional)
   * @param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines. (optional)
   * @param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. (optional)
   * @param includeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited. (optional)
   * @param filters Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes. (optional)
   * @param isFavorite Optional filter by items that are marked as favorite, or not. (optional)
   * @param mediaTypes Optional filter by MediaType. Allows multiple, comma delimited. (optional)
   * @param imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. (optional)
   * @param sortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime. (optional)
   * @param isPlayed Optional filter by items that are played, or not. (optional)
   * @param genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited. (optional)
   * @param officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited. (optional)
   * @param tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited. (optional)
   * @param years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited. (optional)
   * @param enableUserData Optional, include user data. (optional)
   * @param imageTypeLimit Optional, the max number of images to return, per image type. (optional)
   * @param enableImageTypes Optional. The image types to include in the output. (optional)
   * @param person Optional. If specified, results will be filtered to include only those containing the specified person. (optional)
   * @param personIds Optional. If specified, results will be filtered to include only those containing the specified person id. (optional)
   * @param personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited. (optional)
   * @param studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited. (optional)
   * @param artists Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited. (optional)
   * @param excludeArtistIds Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited. (optional)
   * @param artistIds Optional. If specified, results will be filtered to include only those containing the specified artist id. (optional)
   * @param albumArtistIds Optional. If specified, results will be filtered to include only those containing the specified album artist id. (optional)
   * @param contributingArtistIds Optional. If specified, results will be filtered to include only those containing the specified contributing artist id. (optional)
   * @param albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited. (optional)
   * @param albumIds Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited. (optional)
   * @param ids Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited. (optional)
   * @param videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited. (optional)
   * @param minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). (optional)
   * @param isLocked Optional filter by items that are locked. (optional)
   * @param isPlaceHolder Optional filter by items that are placeholders. (optional)
   * @param hasOfficialRating Optional filter by items that have official ratings. (optional)
   * @param collapseBoxSetItems Whether or not to hide items behind their boxsets. (optional)
   * @param minWidth Optional. Filter by the minimum width of the item. (optional)
   * @param minHeight Optional. Filter by the minimum height of the item. (optional)
   * @param maxWidth Optional. Filter by the maximum width of the item. (optional)
   * @param maxHeight Optional. Filter by the maximum height of the item. (optional)
   * @param is3D Optional filter by items that are 3D, or not. (optional)
   * @param seriesStatus Optional filter by Series Status. Allows multiple, comma delimited. (optional)
   * @param nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string. (optional)
   * @param nameStartsWith Optional filter by items whose name is sorted equally than a given input string. (optional)
   * @param nameLessThan Optional filter by items whose name is equally or lesser than a given input string. (optional)
   * @param studioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited. (optional)
   * @param genreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited. (optional)
   * @param enableTotalRecordCount Optional. Enable the total record count. (optional, default to true)
   * @param enableImages Optional, include image information in output. (optional, default to true)
   * @return ApiResponse&lt;BaseItemDtoQueryResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BaseItemDtoQueryResult> getItemsWithHttpInfo(UUID userId, String maxOfficialRating, Boolean hasThemeSong, Boolean hasThemeVideo, Boolean hasSubtitles, Boolean hasSpecialFeature, Boolean hasTrailer, UUID adjacentTo, Integer indexNumber, Integer parentIndexNumber, Boolean hasParentalRating, Boolean isHd, Boolean is4K, List<LocationType> locationTypes, List<LocationType> excludeLocationTypes, Boolean isMissing, Boolean isUnaired, Double minCommunityRating, Double minCriticRating, OffsetDateTime minPremiereDate, OffsetDateTime minDateLastSaved, OffsetDateTime minDateLastSavedForUser, OffsetDateTime maxPremiereDate, Boolean hasOverview, Boolean hasImdbId, Boolean hasTmdbId, Boolean hasTvdbId, Boolean isMovie, Boolean isSeries, Boolean isNews, Boolean isKids, Boolean isSports, List<UUID> excludeItemIds, Integer startIndex, Integer limit, Boolean recursive, String searchTerm, List<SortOrder> sortOrder, UUID parentId, List<ItemFields> fields, List<BaseItemKind> excludeItemTypes, List<BaseItemKind> includeItemTypes, List<ItemFilter> filters, Boolean isFavorite, List<MediaType> mediaTypes, List<ImageType> imageTypes, List<ItemSortBy> sortBy, Boolean isPlayed, List<String> genres, List<String> officialRatings, List<String> tags, List<Integer> years, Boolean enableUserData, Integer imageTypeLimit, List<ImageType> enableImageTypes, String person, List<UUID> personIds, List<String> personTypes, List<String> studios, List<String> artists, List<UUID> excludeArtistIds, List<UUID> artistIds, List<UUID> albumArtistIds, List<UUID> contributingArtistIds, List<String> albums, List<UUID> albumIds, List<UUID> ids, List<VideoType> videoTypes, String minOfficialRating, Boolean isLocked, Boolean isPlaceHolder, Boolean hasOfficialRating, Boolean collapseBoxSetItems, Integer minWidth, Integer minHeight, Integer maxWidth, Integer maxHeight, Boolean is3D, List<SeriesStatus> seriesStatus, String nameStartsWithOrGreater, String nameStartsWith, String nameLessThan, List<UUID> studioIds, List<UUID> genreIds, Boolean enableTotalRecordCount, Boolean enableImages) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getItemsRequestBuilder(userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, indexNumber, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, isMovie, isSeries, isNews, isKids, isSports, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getItems", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BaseItemDtoQueryResult>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<BaseItemDtoQueryResult>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BaseItemDtoQueryResult>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getItemsRequestBuilder(UUID userId, String maxOfficialRating, Boolean hasThemeSong, Boolean hasThemeVideo, Boolean hasSubtitles, Boolean hasSpecialFeature, Boolean hasTrailer, UUID adjacentTo, Integer indexNumber, Integer parentIndexNumber, Boolean hasParentalRating, Boolean isHd, Boolean is4K, List<LocationType> locationTypes, List<LocationType> excludeLocationTypes, Boolean isMissing, Boolean isUnaired, Double minCommunityRating, Double minCriticRating, OffsetDateTime minPremiereDate, OffsetDateTime minDateLastSaved, OffsetDateTime minDateLastSavedForUser, OffsetDateTime maxPremiereDate, Boolean hasOverview, Boolean hasImdbId, Boolean hasTmdbId, Boolean hasTvdbId, Boolean isMovie, Boolean isSeries, Boolean isNews, Boolean isKids, Boolean isSports, List<UUID> excludeItemIds, Integer startIndex, Integer limit, Boolean recursive, String searchTerm, List<SortOrder> sortOrder, UUID parentId, List<ItemFields> fields, List<BaseItemKind> excludeItemTypes, List<BaseItemKind> includeItemTypes, List<ItemFilter> filters, Boolean isFavorite, List<MediaType> mediaTypes, List<ImageType> imageTypes, List<ItemSortBy> sortBy, Boolean isPlayed, List<String> genres, List<String> officialRatings, List<String> tags, List<Integer> years, Boolean enableUserData, Integer imageTypeLimit, List<ImageType> enableImageTypes, String person, List<UUID> personIds, List<String> personTypes, List<String> studios, List<String> artists, List<UUID> excludeArtistIds, List<UUID> artistIds, List<UUID> albumArtistIds, List<UUID> contributingArtistIds, List<String> albums, List<UUID> albumIds, List<UUID> ids, List<VideoType> videoTypes, String minOfficialRating, Boolean isLocked, Boolean isPlaceHolder, Boolean hasOfficialRating, Boolean collapseBoxSetItems, Integer minWidth, Integer minHeight, Integer maxWidth, Integer maxHeight, Boolean is3D, List<SeriesStatus> seriesStatus, String nameStartsWithOrGreater, String nameStartsWith, String nameLessThan, List<UUID> studioIds, List<UUID> genreIds, Boolean enableTotalRecordCount, Boolean enableImages) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/Items";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "userId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("userId", userId));
    localVarQueryParameterBaseName = "maxOfficialRating";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("maxOfficialRating", maxOfficialRating));
    localVarQueryParameterBaseName = "hasThemeSong";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasThemeSong", hasThemeSong));
    localVarQueryParameterBaseName = "hasThemeVideo";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasThemeVideo", hasThemeVideo));
    localVarQueryParameterBaseName = "hasSubtitles";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasSubtitles", hasSubtitles));
    localVarQueryParameterBaseName = "hasSpecialFeature";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasSpecialFeature", hasSpecialFeature));
    localVarQueryParameterBaseName = "hasTrailer";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasTrailer", hasTrailer));
    localVarQueryParameterBaseName = "adjacentTo";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("adjacentTo", adjacentTo));
    localVarQueryParameterBaseName = "indexNumber";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("indexNumber", indexNumber));
    localVarQueryParameterBaseName = "parentIndexNumber";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("parentIndexNumber", parentIndexNumber));
    localVarQueryParameterBaseName = "hasParentalRating";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasParentalRating", hasParentalRating));
    localVarQueryParameterBaseName = "isHd";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isHd", isHd));
    localVarQueryParameterBaseName = "is4K";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("is4K", is4K));
    localVarQueryParameterBaseName = "locationTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "locationTypes", locationTypes));
    localVarQueryParameterBaseName = "excludeLocationTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "excludeLocationTypes", excludeLocationTypes));
    localVarQueryParameterBaseName = "isMissing";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isMissing", isMissing));
    localVarQueryParameterBaseName = "isUnaired";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isUnaired", isUnaired));
    localVarQueryParameterBaseName = "minCommunityRating";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("minCommunityRating", minCommunityRating));
    localVarQueryParameterBaseName = "minCriticRating";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("minCriticRating", minCriticRating));
    localVarQueryParameterBaseName = "minPremiereDate";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("minPremiereDate", minPremiereDate));
    localVarQueryParameterBaseName = "minDateLastSaved";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("minDateLastSaved", minDateLastSaved));
    localVarQueryParameterBaseName = "minDateLastSavedForUser";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("minDateLastSavedForUser", minDateLastSavedForUser));
    localVarQueryParameterBaseName = "maxPremiereDate";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("maxPremiereDate", maxPremiereDate));
    localVarQueryParameterBaseName = "hasOverview";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasOverview", hasOverview));
    localVarQueryParameterBaseName = "hasImdbId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasImdbId", hasImdbId));
    localVarQueryParameterBaseName = "hasTmdbId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasTmdbId", hasTmdbId));
    localVarQueryParameterBaseName = "hasTvdbId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasTvdbId", hasTvdbId));
    localVarQueryParameterBaseName = "isMovie";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isMovie", isMovie));
    localVarQueryParameterBaseName = "isSeries";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isSeries", isSeries));
    localVarQueryParameterBaseName = "isNews";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isNews", isNews));
    localVarQueryParameterBaseName = "isKids";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isKids", isKids));
    localVarQueryParameterBaseName = "isSports";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isSports", isSports));
    localVarQueryParameterBaseName = "excludeItemIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "excludeItemIds", excludeItemIds));
    localVarQueryParameterBaseName = "startIndex";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("startIndex", startIndex));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
    localVarQueryParameterBaseName = "recursive";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursive", recursive));
    localVarQueryParameterBaseName = "searchTerm";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("searchTerm", searchTerm));
    localVarQueryParameterBaseName = "sortOrder";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "sortOrder", sortOrder));
    localVarQueryParameterBaseName = "parentId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("parentId", parentId));
    localVarQueryParameterBaseName = "fields";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "fields", fields));
    localVarQueryParameterBaseName = "excludeItemTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "excludeItemTypes", excludeItemTypes));
    localVarQueryParameterBaseName = "includeItemTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "includeItemTypes", includeItemTypes));
    localVarQueryParameterBaseName = "filters";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "filters", filters));
    localVarQueryParameterBaseName = "isFavorite";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isFavorite", isFavorite));
    localVarQueryParameterBaseName = "mediaTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "mediaTypes", mediaTypes));
    localVarQueryParameterBaseName = "imageTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "imageTypes", imageTypes));
    localVarQueryParameterBaseName = "sortBy";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "sortBy", sortBy));
    localVarQueryParameterBaseName = "isPlayed";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isPlayed", isPlayed));
    localVarQueryParameterBaseName = "genres";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "genres", genres));
    localVarQueryParameterBaseName = "officialRatings";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "officialRatings", officialRatings));
    localVarQueryParameterBaseName = "tags";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "tags", tags));
    localVarQueryParameterBaseName = "years";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "years", years));
    localVarQueryParameterBaseName = "enableUserData";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("enableUserData", enableUserData));
    localVarQueryParameterBaseName = "imageTypeLimit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("imageTypeLimit", imageTypeLimit));
    localVarQueryParameterBaseName = "enableImageTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "enableImageTypes", enableImageTypes));
    localVarQueryParameterBaseName = "person";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("person", person));
    localVarQueryParameterBaseName = "personIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "personIds", personIds));
    localVarQueryParameterBaseName = "personTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "personTypes", personTypes));
    localVarQueryParameterBaseName = "studios";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "studios", studios));
    localVarQueryParameterBaseName = "artists";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "artists", artists));
    localVarQueryParameterBaseName = "excludeArtistIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "excludeArtistIds", excludeArtistIds));
    localVarQueryParameterBaseName = "artistIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "artistIds", artistIds));
    localVarQueryParameterBaseName = "albumArtistIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "albumArtistIds", albumArtistIds));
    localVarQueryParameterBaseName = "contributingArtistIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "contributingArtistIds", contributingArtistIds));
    localVarQueryParameterBaseName = "albums";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "albums", albums));
    localVarQueryParameterBaseName = "albumIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "albumIds", albumIds));
    localVarQueryParameterBaseName = "ids";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "ids", ids));
    localVarQueryParameterBaseName = "videoTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "videoTypes", videoTypes));
    localVarQueryParameterBaseName = "minOfficialRating";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("minOfficialRating", minOfficialRating));
    localVarQueryParameterBaseName = "isLocked";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isLocked", isLocked));
    localVarQueryParameterBaseName = "isPlaceHolder";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("isPlaceHolder", isPlaceHolder));
    localVarQueryParameterBaseName = "hasOfficialRating";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hasOfficialRating", hasOfficialRating));
    localVarQueryParameterBaseName = "collapseBoxSetItems";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("collapseBoxSetItems", collapseBoxSetItems));
    localVarQueryParameterBaseName = "minWidth";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("minWidth", minWidth));
    localVarQueryParameterBaseName = "minHeight";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("minHeight", minHeight));
    localVarQueryParameterBaseName = "maxWidth";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("maxWidth", maxWidth));
    localVarQueryParameterBaseName = "maxHeight";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("maxHeight", maxHeight));
    localVarQueryParameterBaseName = "is3D";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("is3D", is3D));
    localVarQueryParameterBaseName = "seriesStatus";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "seriesStatus", seriesStatus));
    localVarQueryParameterBaseName = "nameStartsWithOrGreater";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nameStartsWithOrGreater", nameStartsWithOrGreater));
    localVarQueryParameterBaseName = "nameStartsWith";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nameStartsWith", nameStartsWith));
    localVarQueryParameterBaseName = "nameLessThan";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nameLessThan", nameLessThan));
    localVarQueryParameterBaseName = "studioIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "studioIds", studioIds));
    localVarQueryParameterBaseName = "genreIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "genreIds", genreIds));
    localVarQueryParameterBaseName = "enableTotalRecordCount";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("enableTotalRecordCount", enableTotalRecordCount));
    localVarQueryParameterBaseName = "enableImages";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("enableImages", enableImages));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json, application/json; profile=CamelCase, application/json; profile=PascalCase");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Gets items based on a query.
   * 
   * @param userId The user id. (optional)
   * @param startIndex The start index. (optional)
   * @param limit The item limit. (optional)
   * @param searchTerm The search term. (optional)
   * @param parentId Specify this to localize the search to a specific item or folder. Omit to use the root. (optional)
   * @param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines. (optional)
   * @param mediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited. (optional)
   * @param enableUserData Optional. Include user data. (optional)
   * @param imageTypeLimit Optional. The max number of images to return, per image type. (optional)
   * @param enableImageTypes Optional. The image types to include in the output. (optional)
   * @param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. (optional)
   * @param includeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited. (optional)
   * @param enableTotalRecordCount Optional. Enable the total record count. (optional, default to true)
   * @param enableImages Optional. Include image information in output. (optional, default to true)
   * @param excludeActiveSessions Optional. Whether to exclude the currently active sessions. (optional, default to false)
   * @return BaseItemDtoQueryResult
   * @throws ApiException if fails to make API call
   */
  public BaseItemDtoQueryResult getResumeItems(UUID userId, Integer startIndex, Integer limit, String searchTerm, UUID parentId, List<ItemFields> fields, List<MediaType> mediaTypes, Boolean enableUserData, Integer imageTypeLimit, List<ImageType> enableImageTypes, List<BaseItemKind> excludeItemTypes, List<BaseItemKind> includeItemTypes, Boolean enableTotalRecordCount, Boolean enableImages, Boolean excludeActiveSessions) throws ApiException {
    ApiResponse<BaseItemDtoQueryResult> localVarResponse = getResumeItemsWithHttpInfo(userId, startIndex, limit, searchTerm, parentId, fields, mediaTypes, enableUserData, imageTypeLimit, enableImageTypes, excludeItemTypes, includeItemTypes, enableTotalRecordCount, enableImages, excludeActiveSessions);
    return localVarResponse.getData();
  }

  /**
   * Gets items based on a query.
   * 
   * @param userId The user id. (optional)
   * @param startIndex The start index. (optional)
   * @param limit The item limit. (optional)
   * @param searchTerm The search term. (optional)
   * @param parentId Specify this to localize the search to a specific item or folder. Omit to use the root. (optional)
   * @param fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines. (optional)
   * @param mediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited. (optional)
   * @param enableUserData Optional. Include user data. (optional)
   * @param imageTypeLimit Optional. The max number of images to return, per image type. (optional)
   * @param enableImageTypes Optional. The image types to include in the output. (optional)
   * @param excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. (optional)
   * @param includeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited. (optional)
   * @param enableTotalRecordCount Optional. Enable the total record count. (optional, default to true)
   * @param enableImages Optional. Include image information in output. (optional, default to true)
   * @param excludeActiveSessions Optional. Whether to exclude the currently active sessions. (optional, default to false)
   * @return ApiResponse&lt;BaseItemDtoQueryResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BaseItemDtoQueryResult> getResumeItemsWithHttpInfo(UUID userId, Integer startIndex, Integer limit, String searchTerm, UUID parentId, List<ItemFields> fields, List<MediaType> mediaTypes, Boolean enableUserData, Integer imageTypeLimit, List<ImageType> enableImageTypes, List<BaseItemKind> excludeItemTypes, List<BaseItemKind> includeItemTypes, Boolean enableTotalRecordCount, Boolean enableImages, Boolean excludeActiveSessions) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getResumeItemsRequestBuilder(userId, startIndex, limit, searchTerm, parentId, fields, mediaTypes, enableUserData, imageTypeLimit, enableImageTypes, excludeItemTypes, includeItemTypes, enableTotalRecordCount, enableImages, excludeActiveSessions);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getResumeItems", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BaseItemDtoQueryResult>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<BaseItemDtoQueryResult>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BaseItemDtoQueryResult>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getResumeItemsRequestBuilder(UUID userId, Integer startIndex, Integer limit, String searchTerm, UUID parentId, List<ItemFields> fields, List<MediaType> mediaTypes, Boolean enableUserData, Integer imageTypeLimit, List<ImageType> enableImageTypes, List<BaseItemKind> excludeItemTypes, List<BaseItemKind> includeItemTypes, Boolean enableTotalRecordCount, Boolean enableImages, Boolean excludeActiveSessions) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/UserItems/Resume";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "userId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("userId", userId));
    localVarQueryParameterBaseName = "startIndex";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("startIndex", startIndex));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
    localVarQueryParameterBaseName = "searchTerm";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("searchTerm", searchTerm));
    localVarQueryParameterBaseName = "parentId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("parentId", parentId));
    localVarQueryParameterBaseName = "fields";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "fields", fields));
    localVarQueryParameterBaseName = "mediaTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "mediaTypes", mediaTypes));
    localVarQueryParameterBaseName = "enableUserData";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("enableUserData", enableUserData));
    localVarQueryParameterBaseName = "imageTypeLimit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("imageTypeLimit", imageTypeLimit));
    localVarQueryParameterBaseName = "enableImageTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "enableImageTypes", enableImageTypes));
    localVarQueryParameterBaseName = "excludeItemTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "excludeItemTypes", excludeItemTypes));
    localVarQueryParameterBaseName = "includeItemTypes";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "includeItemTypes", includeItemTypes));
    localVarQueryParameterBaseName = "enableTotalRecordCount";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("enableTotalRecordCount", enableTotalRecordCount));
    localVarQueryParameterBaseName = "enableImages";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("enableImages", enableImages));
    localVarQueryParameterBaseName = "excludeActiveSessions";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("excludeActiveSessions", excludeActiveSessions));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json, application/json; profile=CamelCase, application/json; profile=PascalCase");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Update Item User Data.
   * 
   * @param itemId The item id. (required)
   * @param updateUserItemDataDto New user data object. (required)
   * @param userId The user id. (optional)
   * @return UserItemDataDto
   * @throws ApiException if fails to make API call
   */
  public UserItemDataDto updateItemUserData(UUID itemId, UpdateUserItemDataDto updateUserItemDataDto, UUID userId) throws ApiException {
    ApiResponse<UserItemDataDto> localVarResponse = updateItemUserDataWithHttpInfo(itemId, updateUserItemDataDto, userId);
    return localVarResponse.getData();
  }

  /**
   * Update Item User Data.
   * 
   * @param itemId The item id. (required)
   * @param updateUserItemDataDto New user data object. (required)
   * @param userId The user id. (optional)
   * @return ApiResponse&lt;UserItemDataDto&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UserItemDataDto> updateItemUserDataWithHttpInfo(UUID itemId, UpdateUserItemDataDto updateUserItemDataDto, UUID userId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateItemUserDataRequestBuilder(itemId, updateUserItemDataDto, userId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateItemUserData", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<UserItemDataDto>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<UserItemDataDto>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<UserItemDataDto>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateItemUserDataRequestBuilder(UUID itemId, UpdateUserItemDataDto updateUserItemDataDto, UUID userId) throws ApiException {
    // verify the required parameter 'itemId' is set
    if (itemId == null) {
      throw new ApiException(400, "Missing the required parameter 'itemId' when calling updateItemUserData");
    }
    // verify the required parameter 'updateUserItemDataDto' is set
    if (updateUserItemDataDto == null) {
      throw new ApiException(400, "Missing the required parameter 'updateUserItemDataDto' when calling updateItemUserData");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/UserItems/{itemId}/UserData"
        .replace("{itemId}", ApiClient.urlEncode(itemId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "userId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("userId", userId));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, application/json; profile=CamelCase, application/json; profile=PascalCase");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateUserItemDataDto);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
