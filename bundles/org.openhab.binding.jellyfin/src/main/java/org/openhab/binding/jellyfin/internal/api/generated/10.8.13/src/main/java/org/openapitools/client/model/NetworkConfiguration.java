/*
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.8.13
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines the Jellyfin.Networking.Configuration.NetworkConfiguration.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-12-27T20:32:44.334408221+01:00[Europe/Zurich]", comments = "Generator version: 7.10.0")
public class NetworkConfiguration {
  public static final String SERIALIZED_NAME_REQUIRE_HTTPS = "RequireHttps";
  @SerializedName(SERIALIZED_NAME_REQUIRE_HTTPS)
  @javax.annotation.Nullable
  private Boolean requireHttps;

  public static final String SERIALIZED_NAME_CERTIFICATE_PATH = "CertificatePath";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_PATH)
  @javax.annotation.Nullable
  private String certificatePath;

  public static final String SERIALIZED_NAME_CERTIFICATE_PASSWORD = "CertificatePassword";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_PASSWORD)
  @javax.annotation.Nullable
  private String certificatePassword;

  public static final String SERIALIZED_NAME_BASE_URL = "BaseUrl";
  @SerializedName(SERIALIZED_NAME_BASE_URL)
  @javax.annotation.Nullable
  private String baseUrl;

  public static final String SERIALIZED_NAME_PUBLIC_HTTPS_PORT = "PublicHttpsPort";
  @SerializedName(SERIALIZED_NAME_PUBLIC_HTTPS_PORT)
  @javax.annotation.Nullable
  private Integer publicHttpsPort;

  public static final String SERIALIZED_NAME_HTTP_SERVER_PORT_NUMBER = "HttpServerPortNumber";
  @SerializedName(SERIALIZED_NAME_HTTP_SERVER_PORT_NUMBER)
  @javax.annotation.Nullable
  private Integer httpServerPortNumber;

  public static final String SERIALIZED_NAME_HTTPS_PORT_NUMBER = "HttpsPortNumber";
  @SerializedName(SERIALIZED_NAME_HTTPS_PORT_NUMBER)
  @javax.annotation.Nullable
  private Integer httpsPortNumber;

  public static final String SERIALIZED_NAME_ENABLE_HTTPS = "EnableHttps";
  @SerializedName(SERIALIZED_NAME_ENABLE_HTTPS)
  @javax.annotation.Nullable
  private Boolean enableHttps;

  public static final String SERIALIZED_NAME_PUBLIC_PORT = "PublicPort";
  @SerializedName(SERIALIZED_NAME_PUBLIC_PORT)
  @javax.annotation.Nullable
  private Integer publicPort;

  public static final String SERIALIZED_NAME_UPN_P_CREATE_HTTP_PORT_MAP = "UPnPCreateHttpPortMap";
  @SerializedName(SERIALIZED_NAME_UPN_P_CREATE_HTTP_PORT_MAP)
  @javax.annotation.Nullable
  private Boolean upnPCreateHttpPortMap;

  public static final String SERIALIZED_NAME_UD_P_PORT_RANGE = "UDPPortRange";
  @SerializedName(SERIALIZED_NAME_UD_P_PORT_RANGE)
  @javax.annotation.Nullable
  private String udPPortRange;

  public static final String SERIALIZED_NAME_ENABLE_I_P_V6 = "EnableIPV6";
  @SerializedName(SERIALIZED_NAME_ENABLE_I_P_V6)
  @javax.annotation.Nullable
  private Boolean enableIPV6;

  public static final String SERIALIZED_NAME_ENABLE_I_P_V4 = "EnableIPV4";
  @SerializedName(SERIALIZED_NAME_ENABLE_I_P_V4)
  @javax.annotation.Nullable
  private Boolean enableIPV4;

  public static final String SERIALIZED_NAME_ENABLE_S_S_D_P_TRACING = "EnableSSDPTracing";
  @SerializedName(SERIALIZED_NAME_ENABLE_S_S_D_P_TRACING)
  @javax.annotation.Nullable
  private Boolean enableSSDPTracing;

  public static final String SERIALIZED_NAME_SS_D_P_TRACING_FILTER = "SSDPTracingFilter";
  @SerializedName(SERIALIZED_NAME_SS_D_P_TRACING_FILTER)
  @javax.annotation.Nullable
  private String ssDPTracingFilter;

  public static final String SERIALIZED_NAME_UD_P_SEND_COUNT = "UDPSendCount";
  @SerializedName(SERIALIZED_NAME_UD_P_SEND_COUNT)
  @javax.annotation.Nullable
  private Integer udPSendCount;

  public static final String SERIALIZED_NAME_UD_P_SEND_DELAY = "UDPSendDelay";
  @SerializedName(SERIALIZED_NAME_UD_P_SEND_DELAY)
  @javax.annotation.Nullable
  private Integer udPSendDelay;

  public static final String SERIALIZED_NAME_IGNORE_VIRTUAL_INTERFACES = "IgnoreVirtualInterfaces";
  @SerializedName(SERIALIZED_NAME_IGNORE_VIRTUAL_INTERFACES)
  @javax.annotation.Nullable
  private Boolean ignoreVirtualInterfaces;

  public static final String SERIALIZED_NAME_VIRTUAL_INTERFACE_NAMES = "VirtualInterfaceNames";
  @SerializedName(SERIALIZED_NAME_VIRTUAL_INTERFACE_NAMES)
  @javax.annotation.Nullable
  private String virtualInterfaceNames;

  public static final String SERIALIZED_NAME_GATEWAY_MONITOR_PERIOD = "GatewayMonitorPeriod";
  @SerializedName(SERIALIZED_NAME_GATEWAY_MONITOR_PERIOD)
  @javax.annotation.Nullable
  private Integer gatewayMonitorPeriod;

  public static final String SERIALIZED_NAME_ENABLE_MULTI_SOCKET_BINDING = "EnableMultiSocketBinding";
  @SerializedName(SERIALIZED_NAME_ENABLE_MULTI_SOCKET_BINDING)
  @javax.annotation.Nullable
  private Boolean enableMultiSocketBinding;

  public static final String SERIALIZED_NAME_TRUST_ALL_I_P6_INTERFACES = "TrustAllIP6Interfaces";
  @SerializedName(SERIALIZED_NAME_TRUST_ALL_I_P6_INTERFACES)
  @javax.annotation.Nullable
  private Boolean trustAllIP6Interfaces;

  public static final String SERIALIZED_NAME_HD_HOMERUN_PORT_RANGE = "HDHomerunPortRange";
  @SerializedName(SERIALIZED_NAME_HD_HOMERUN_PORT_RANGE)
  @javax.annotation.Nullable
  private String hdHomerunPortRange;

  public static final String SERIALIZED_NAME_PUBLISHED_SERVER_URI_BY_SUBNET = "PublishedServerUriBySubnet";
  @SerializedName(SERIALIZED_NAME_PUBLISHED_SERVER_URI_BY_SUBNET)
  @javax.annotation.Nullable
  private List<String> publishedServerUriBySubnet = new ArrayList<>();

  public static final String SERIALIZED_NAME_AUTO_DISCOVERY_TRACING = "AutoDiscoveryTracing";
  @SerializedName(SERIALIZED_NAME_AUTO_DISCOVERY_TRACING)
  @javax.annotation.Nullable
  private Boolean autoDiscoveryTracing;

  public static final String SERIALIZED_NAME_AUTO_DISCOVERY = "AutoDiscovery";
  @SerializedName(SERIALIZED_NAME_AUTO_DISCOVERY)
  @javax.annotation.Nullable
  private Boolean autoDiscovery;

  public static final String SERIALIZED_NAME_REMOTE_I_P_FILTER = "RemoteIPFilter";
  @SerializedName(SERIALIZED_NAME_REMOTE_I_P_FILTER)
  @javax.annotation.Nullable
  private List<String> remoteIPFilter = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_REMOTE_I_P_FILTER_BLACKLIST = "IsRemoteIPFilterBlacklist";
  @SerializedName(SERIALIZED_NAME_IS_REMOTE_I_P_FILTER_BLACKLIST)
  @javax.annotation.Nullable
  private Boolean isRemoteIPFilterBlacklist;

  public static final String SERIALIZED_NAME_ENABLE_U_PN_P = "EnableUPnP";
  @SerializedName(SERIALIZED_NAME_ENABLE_U_PN_P)
  @javax.annotation.Nullable
  private Boolean enableUPnP;

  public static final String SERIALIZED_NAME_ENABLE_REMOTE_ACCESS = "EnableRemoteAccess";
  @SerializedName(SERIALIZED_NAME_ENABLE_REMOTE_ACCESS)
  @javax.annotation.Nullable
  private Boolean enableRemoteAccess;

  public static final String SERIALIZED_NAME_LOCAL_NETWORK_SUBNETS = "LocalNetworkSubnets";
  @SerializedName(SERIALIZED_NAME_LOCAL_NETWORK_SUBNETS)
  @javax.annotation.Nullable
  private List<String> localNetworkSubnets = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOCAL_NETWORK_ADDRESSES = "LocalNetworkAddresses";
  @SerializedName(SERIALIZED_NAME_LOCAL_NETWORK_ADDRESSES)
  @javax.annotation.Nullable
  private List<String> localNetworkAddresses = new ArrayList<>();

  public static final String SERIALIZED_NAME_KNOWN_PROXIES = "KnownProxies";
  @SerializedName(SERIALIZED_NAME_KNOWN_PROXIES)
  @javax.annotation.Nullable
  private List<String> knownProxies = new ArrayList<>();

  public static final String SERIALIZED_NAME_ENABLE_PUBLISHED_SERVER_URI_BY_REQUEST = "EnablePublishedServerUriByRequest";
  @SerializedName(SERIALIZED_NAME_ENABLE_PUBLISHED_SERVER_URI_BY_REQUEST)
  @javax.annotation.Nullable
  private Boolean enablePublishedServerUriByRequest;

  public NetworkConfiguration() {
  }

  public NetworkConfiguration(
     Boolean enableMultiSocketBinding
  ) {
    this();
    this.enableMultiSocketBinding = enableMultiSocketBinding;
  }

  public NetworkConfiguration requireHttps(@javax.annotation.Nullable Boolean requireHttps) {
    this.requireHttps = requireHttps;
    return this;
  }

  /**
   * Gets or sets a value indicating whether the server should force connections over HTTPS.
   * @return requireHttps
   */
  @javax.annotation.Nullable
  public Boolean getRequireHttps() {
    return requireHttps;
  }

  public void setRequireHttps(@javax.annotation.Nullable Boolean requireHttps) {
    this.requireHttps = requireHttps;
  }


  public NetworkConfiguration certificatePath(@javax.annotation.Nullable String certificatePath) {
    this.certificatePath = certificatePath;
    return this;
  }

  /**
   * Gets or sets the filesystem path of an X.509 certificate to use for SSL.
   * @return certificatePath
   */
  @javax.annotation.Nullable
  public String getCertificatePath() {
    return certificatePath;
  }

  public void setCertificatePath(@javax.annotation.Nullable String certificatePath) {
    this.certificatePath = certificatePath;
  }


  public NetworkConfiguration certificatePassword(@javax.annotation.Nullable String certificatePassword) {
    this.certificatePassword = certificatePassword;
    return this;
  }

  /**
   * Gets or sets the password required to access the X.509 certificate data in the file specified by Jellyfin.Networking.Configuration.NetworkConfiguration.CertificatePath.
   * @return certificatePassword
   */
  @javax.annotation.Nullable
  public String getCertificatePassword() {
    return certificatePassword;
  }

  public void setCertificatePassword(@javax.annotation.Nullable String certificatePassword) {
    this.certificatePassword = certificatePassword;
  }


  public NetworkConfiguration baseUrl(@javax.annotation.Nullable String baseUrl) {
    this.baseUrl = baseUrl;
    return this;
  }

  /**
   * Gets or sets a value used to specify the URL prefix that your Jellyfin instance can be accessed at.
   * @return baseUrl
   */
  @javax.annotation.Nullable
  public String getBaseUrl() {
    return baseUrl;
  }

  public void setBaseUrl(@javax.annotation.Nullable String baseUrl) {
    this.baseUrl = baseUrl;
  }


  public NetworkConfiguration publicHttpsPort(@javax.annotation.Nullable Integer publicHttpsPort) {
    this.publicHttpsPort = publicHttpsPort;
    return this;
  }

  /**
   * Gets or sets the public HTTPS port.
   * @return publicHttpsPort
   */
  @javax.annotation.Nullable
  public Integer getPublicHttpsPort() {
    return publicHttpsPort;
  }

  public void setPublicHttpsPort(@javax.annotation.Nullable Integer publicHttpsPort) {
    this.publicHttpsPort = publicHttpsPort;
  }


  public NetworkConfiguration httpServerPortNumber(@javax.annotation.Nullable Integer httpServerPortNumber) {
    this.httpServerPortNumber = httpServerPortNumber;
    return this;
  }

  /**
   * Gets or sets the HTTP server port number.
   * @return httpServerPortNumber
   */
  @javax.annotation.Nullable
  public Integer getHttpServerPortNumber() {
    return httpServerPortNumber;
  }

  public void setHttpServerPortNumber(@javax.annotation.Nullable Integer httpServerPortNumber) {
    this.httpServerPortNumber = httpServerPortNumber;
  }


  public NetworkConfiguration httpsPortNumber(@javax.annotation.Nullable Integer httpsPortNumber) {
    this.httpsPortNumber = httpsPortNumber;
    return this;
  }

  /**
   * Gets or sets the HTTPS server port number.
   * @return httpsPortNumber
   */
  @javax.annotation.Nullable
  public Integer getHttpsPortNumber() {
    return httpsPortNumber;
  }

  public void setHttpsPortNumber(@javax.annotation.Nullable Integer httpsPortNumber) {
    this.httpsPortNumber = httpsPortNumber;
  }


  public NetworkConfiguration enableHttps(@javax.annotation.Nullable Boolean enableHttps) {
    this.enableHttps = enableHttps;
    return this;
  }

  /**
   * Gets or sets a value indicating whether to use HTTPS.
   * @return enableHttps
   */
  @javax.annotation.Nullable
  public Boolean getEnableHttps() {
    return enableHttps;
  }

  public void setEnableHttps(@javax.annotation.Nullable Boolean enableHttps) {
    this.enableHttps = enableHttps;
  }


  public NetworkConfiguration publicPort(@javax.annotation.Nullable Integer publicPort) {
    this.publicPort = publicPort;
    return this;
  }

  /**
   * Gets or sets the public mapped port.
   * @return publicPort
   */
  @javax.annotation.Nullable
  public Integer getPublicPort() {
    return publicPort;
  }

  public void setPublicPort(@javax.annotation.Nullable Integer publicPort) {
    this.publicPort = publicPort;
  }


  public NetworkConfiguration upnPCreateHttpPortMap(@javax.annotation.Nullable Boolean upnPCreateHttpPortMap) {
    this.upnPCreateHttpPortMap = upnPCreateHttpPortMap;
    return this;
  }

  /**
   * Gets or sets a value indicating whether the http port should be mapped as part of UPnP automatic port forwarding.
   * @return upnPCreateHttpPortMap
   */
  @javax.annotation.Nullable
  public Boolean getUpnPCreateHttpPortMap() {
    return upnPCreateHttpPortMap;
  }

  public void setUpnPCreateHttpPortMap(@javax.annotation.Nullable Boolean upnPCreateHttpPortMap) {
    this.upnPCreateHttpPortMap = upnPCreateHttpPortMap;
  }


  public NetworkConfiguration udPPortRange(@javax.annotation.Nullable String udPPortRange) {
    this.udPPortRange = udPPortRange;
    return this;
  }

  /**
   * Gets or sets the UDPPortRange.
   * @return udPPortRange
   */
  @javax.annotation.Nullable
  public String getUdPPortRange() {
    return udPPortRange;
  }

  public void setUdPPortRange(@javax.annotation.Nullable String udPPortRange) {
    this.udPPortRange = udPPortRange;
  }


  public NetworkConfiguration enableIPV6(@javax.annotation.Nullable Boolean enableIPV6) {
    this.enableIPV6 = enableIPV6;
    return this;
  }

  /**
   * Gets or sets a value indicating whether gets or sets IPV6 capability.
   * @return enableIPV6
   */
  @javax.annotation.Nullable
  public Boolean getEnableIPV6() {
    return enableIPV6;
  }

  public void setEnableIPV6(@javax.annotation.Nullable Boolean enableIPV6) {
    this.enableIPV6 = enableIPV6;
  }


  public NetworkConfiguration enableIPV4(@javax.annotation.Nullable Boolean enableIPV4) {
    this.enableIPV4 = enableIPV4;
    return this;
  }

  /**
   * Gets or sets a value indicating whether gets or sets IPV4 capability.
   * @return enableIPV4
   */
  @javax.annotation.Nullable
  public Boolean getEnableIPV4() {
    return enableIPV4;
  }

  public void setEnableIPV4(@javax.annotation.Nullable Boolean enableIPV4) {
    this.enableIPV4 = enableIPV4;
  }


  public NetworkConfiguration enableSSDPTracing(@javax.annotation.Nullable Boolean enableSSDPTracing) {
    this.enableSSDPTracing = enableSSDPTracing;
    return this;
  }

  /**
   * Gets or sets a value indicating whether detailed SSDP logs are sent to the console/log.  \&quot;Emby.Dlna\&quot;: \&quot;Debug\&quot; must be set in logging.default.json for this property to have any effect.
   * @return enableSSDPTracing
   */
  @javax.annotation.Nullable
  public Boolean getEnableSSDPTracing() {
    return enableSSDPTracing;
  }

  public void setEnableSSDPTracing(@javax.annotation.Nullable Boolean enableSSDPTracing) {
    this.enableSSDPTracing = enableSSDPTracing;
  }


  public NetworkConfiguration ssDPTracingFilter(@javax.annotation.Nullable String ssDPTracingFilter) {
    this.ssDPTracingFilter = ssDPTracingFilter;
    return this;
  }

  /**
   * Gets or sets the SSDPTracingFilter  Gets or sets a value indicating whether an IP address is to be used to filter the detailed ssdp logs that are being sent to the console/log.  If the setting \&quot;Emby.Dlna\&quot;: \&quot;Debug\&quot; msut be set in logging.default.json for this property to work.
   * @return ssDPTracingFilter
   */
  @javax.annotation.Nullable
  public String getSsDPTracingFilter() {
    return ssDPTracingFilter;
  }

  public void setSsDPTracingFilter(@javax.annotation.Nullable String ssDPTracingFilter) {
    this.ssDPTracingFilter = ssDPTracingFilter;
  }


  public NetworkConfiguration udPSendCount(@javax.annotation.Nullable Integer udPSendCount) {
    this.udPSendCount = udPSendCount;
    return this;
  }

  /**
   * Gets or sets the number of times SSDP UDP messages are sent.
   * @return udPSendCount
   */
  @javax.annotation.Nullable
  public Integer getUdPSendCount() {
    return udPSendCount;
  }

  public void setUdPSendCount(@javax.annotation.Nullable Integer udPSendCount) {
    this.udPSendCount = udPSendCount;
  }


  public NetworkConfiguration udPSendDelay(@javax.annotation.Nullable Integer udPSendDelay) {
    this.udPSendDelay = udPSendDelay;
    return this;
  }

  /**
   * Gets or sets the delay between each groups of SSDP messages (in ms).
   * @return udPSendDelay
   */
  @javax.annotation.Nullable
  public Integer getUdPSendDelay() {
    return udPSendDelay;
  }

  public void setUdPSendDelay(@javax.annotation.Nullable Integer udPSendDelay) {
    this.udPSendDelay = udPSendDelay;
  }


  public NetworkConfiguration ignoreVirtualInterfaces(@javax.annotation.Nullable Boolean ignoreVirtualInterfaces) {
    this.ignoreVirtualInterfaces = ignoreVirtualInterfaces;
    return this;
  }

  /**
   * Gets or sets a value indicating whether address names that match Jellyfin.Networking.Configuration.NetworkConfiguration.VirtualInterfaceNames should be Ignore for the purposes of binding.
   * @return ignoreVirtualInterfaces
   */
  @javax.annotation.Nullable
  public Boolean getIgnoreVirtualInterfaces() {
    return ignoreVirtualInterfaces;
  }

  public void setIgnoreVirtualInterfaces(@javax.annotation.Nullable Boolean ignoreVirtualInterfaces) {
    this.ignoreVirtualInterfaces = ignoreVirtualInterfaces;
  }


  public NetworkConfiguration virtualInterfaceNames(@javax.annotation.Nullable String virtualInterfaceNames) {
    this.virtualInterfaceNames = virtualInterfaceNames;
    return this;
  }

  /**
   * Gets or sets a value indicating the interfaces that should be ignored. The list can be comma separated. &lt;seealso cref&#x3D;\&quot;P:Jellyfin.Networking.Configuration.NetworkConfiguration.IgnoreVirtualInterfaces\&quot; /&gt;.
   * @return virtualInterfaceNames
   */
  @javax.annotation.Nullable
  public String getVirtualInterfaceNames() {
    return virtualInterfaceNames;
  }

  public void setVirtualInterfaceNames(@javax.annotation.Nullable String virtualInterfaceNames) {
    this.virtualInterfaceNames = virtualInterfaceNames;
  }


  public NetworkConfiguration gatewayMonitorPeriod(@javax.annotation.Nullable Integer gatewayMonitorPeriod) {
    this.gatewayMonitorPeriod = gatewayMonitorPeriod;
    return this;
  }

  /**
   * Gets or sets the time (in seconds) between the pings of SSDP gateway monitor.
   * @return gatewayMonitorPeriod
   */
  @javax.annotation.Nullable
  public Integer getGatewayMonitorPeriod() {
    return gatewayMonitorPeriod;
  }

  public void setGatewayMonitorPeriod(@javax.annotation.Nullable Integer gatewayMonitorPeriod) {
    this.gatewayMonitorPeriod = gatewayMonitorPeriod;
  }


  /**
   * Gets a value indicating whether multi-socket binding is available.
   * @return enableMultiSocketBinding
   */
  @javax.annotation.Nullable
  public Boolean getEnableMultiSocketBinding() {
    return enableMultiSocketBinding;
  }



  public NetworkConfiguration trustAllIP6Interfaces(@javax.annotation.Nullable Boolean trustAllIP6Interfaces) {
    this.trustAllIP6Interfaces = trustAllIP6Interfaces;
    return this;
  }

  /**
   * Gets or sets a value indicating whether all IPv6 interfaces should be treated as on the internal network.  Depending on the address range implemented ULA ranges might not be used.
   * @return trustAllIP6Interfaces
   */
  @javax.annotation.Nullable
  public Boolean getTrustAllIP6Interfaces() {
    return trustAllIP6Interfaces;
  }

  public void setTrustAllIP6Interfaces(@javax.annotation.Nullable Boolean trustAllIP6Interfaces) {
    this.trustAllIP6Interfaces = trustAllIP6Interfaces;
  }


  public NetworkConfiguration hdHomerunPortRange(@javax.annotation.Nullable String hdHomerunPortRange) {
    this.hdHomerunPortRange = hdHomerunPortRange;
    return this;
  }

  /**
   * Gets or sets the ports that HDHomerun uses.
   * @return hdHomerunPortRange
   */
  @javax.annotation.Nullable
  public String getHdHomerunPortRange() {
    return hdHomerunPortRange;
  }

  public void setHdHomerunPortRange(@javax.annotation.Nullable String hdHomerunPortRange) {
    this.hdHomerunPortRange = hdHomerunPortRange;
  }


  public NetworkConfiguration publishedServerUriBySubnet(@javax.annotation.Nullable List<String> publishedServerUriBySubnet) {
    this.publishedServerUriBySubnet = publishedServerUriBySubnet;
    return this;
  }

  public NetworkConfiguration addPublishedServerUriBySubnetItem(String publishedServerUriBySubnetItem) {
    if (this.publishedServerUriBySubnet == null) {
      this.publishedServerUriBySubnet = new ArrayList<>();
    }
    this.publishedServerUriBySubnet.add(publishedServerUriBySubnetItem);
    return this;
  }

  /**
   * Gets or sets the PublishedServerUriBySubnet  Gets or sets PublishedServerUri to advertise for specific subnets.
   * @return publishedServerUriBySubnet
   */
  @javax.annotation.Nullable
  public List<String> getPublishedServerUriBySubnet() {
    return publishedServerUriBySubnet;
  }

  public void setPublishedServerUriBySubnet(@javax.annotation.Nullable List<String> publishedServerUriBySubnet) {
    this.publishedServerUriBySubnet = publishedServerUriBySubnet;
  }


  public NetworkConfiguration autoDiscoveryTracing(@javax.annotation.Nullable Boolean autoDiscoveryTracing) {
    this.autoDiscoveryTracing = autoDiscoveryTracing;
    return this;
  }

  /**
   * Gets or sets a value indicating whether Autodiscovery tracing is enabled.
   * @return autoDiscoveryTracing
   */
  @javax.annotation.Nullable
  public Boolean getAutoDiscoveryTracing() {
    return autoDiscoveryTracing;
  }

  public void setAutoDiscoveryTracing(@javax.annotation.Nullable Boolean autoDiscoveryTracing) {
    this.autoDiscoveryTracing = autoDiscoveryTracing;
  }


  public NetworkConfiguration autoDiscovery(@javax.annotation.Nullable Boolean autoDiscovery) {
    this.autoDiscovery = autoDiscovery;
    return this;
  }

  /**
   * Gets or sets a value indicating whether Autodiscovery is enabled.
   * @return autoDiscovery
   */
  @javax.annotation.Nullable
  public Boolean getAutoDiscovery() {
    return autoDiscovery;
  }

  public void setAutoDiscovery(@javax.annotation.Nullable Boolean autoDiscovery) {
    this.autoDiscovery = autoDiscovery;
  }


  public NetworkConfiguration remoteIPFilter(@javax.annotation.Nullable List<String> remoteIPFilter) {
    this.remoteIPFilter = remoteIPFilter;
    return this;
  }

  public NetworkConfiguration addRemoteIPFilterItem(String remoteIPFilterItem) {
    if (this.remoteIPFilter == null) {
      this.remoteIPFilter = new ArrayList<>();
    }
    this.remoteIPFilter.add(remoteIPFilterItem);
    return this;
  }

  /**
   * Gets or sets the filter for remote IP connectivity. Used in conjuntion with &lt;seealso cref&#x3D;\&quot;P:Jellyfin.Networking.Configuration.NetworkConfiguration.IsRemoteIPFilterBlacklist\&quot; /&gt;.
   * @return remoteIPFilter
   */
  @javax.annotation.Nullable
  public List<String> getRemoteIPFilter() {
    return remoteIPFilter;
  }

  public void setRemoteIPFilter(@javax.annotation.Nullable List<String> remoteIPFilter) {
    this.remoteIPFilter = remoteIPFilter;
  }


  public NetworkConfiguration isRemoteIPFilterBlacklist(@javax.annotation.Nullable Boolean isRemoteIPFilterBlacklist) {
    this.isRemoteIPFilterBlacklist = isRemoteIPFilterBlacklist;
    return this;
  }

  /**
   * Gets or sets a value indicating whether &lt;seealso cref&#x3D;\&quot;P:Jellyfin.Networking.Configuration.NetworkConfiguration.RemoteIPFilter\&quot; /&gt; contains a blacklist or a whitelist. Default is a whitelist.
   * @return isRemoteIPFilterBlacklist
   */
  @javax.annotation.Nullable
  public Boolean getIsRemoteIPFilterBlacklist() {
    return isRemoteIPFilterBlacklist;
  }

  public void setIsRemoteIPFilterBlacklist(@javax.annotation.Nullable Boolean isRemoteIPFilterBlacklist) {
    this.isRemoteIPFilterBlacklist = isRemoteIPFilterBlacklist;
  }


  public NetworkConfiguration enableUPnP(@javax.annotation.Nullable Boolean enableUPnP) {
    this.enableUPnP = enableUPnP;
    return this;
  }

  /**
   * Gets or sets a value indicating whether to enable automatic port forwarding.
   * @return enableUPnP
   */
  @javax.annotation.Nullable
  public Boolean getEnableUPnP() {
    return enableUPnP;
  }

  public void setEnableUPnP(@javax.annotation.Nullable Boolean enableUPnP) {
    this.enableUPnP = enableUPnP;
  }


  public NetworkConfiguration enableRemoteAccess(@javax.annotation.Nullable Boolean enableRemoteAccess) {
    this.enableRemoteAccess = enableRemoteAccess;
    return this;
  }

  /**
   * Gets or sets a value indicating whether access outside of the LAN is permitted.
   * @return enableRemoteAccess
   */
  @javax.annotation.Nullable
  public Boolean getEnableRemoteAccess() {
    return enableRemoteAccess;
  }

  public void setEnableRemoteAccess(@javax.annotation.Nullable Boolean enableRemoteAccess) {
    this.enableRemoteAccess = enableRemoteAccess;
  }


  public NetworkConfiguration localNetworkSubnets(@javax.annotation.Nullable List<String> localNetworkSubnets) {
    this.localNetworkSubnets = localNetworkSubnets;
    return this;
  }

  public NetworkConfiguration addLocalNetworkSubnetsItem(String localNetworkSubnetsItem) {
    if (this.localNetworkSubnets == null) {
      this.localNetworkSubnets = new ArrayList<>();
    }
    this.localNetworkSubnets.add(localNetworkSubnetsItem);
    return this;
  }

  /**
   * Gets or sets the subnets that are deemed to make up the LAN.
   * @return localNetworkSubnets
   */
  @javax.annotation.Nullable
  public List<String> getLocalNetworkSubnets() {
    return localNetworkSubnets;
  }

  public void setLocalNetworkSubnets(@javax.annotation.Nullable List<String> localNetworkSubnets) {
    this.localNetworkSubnets = localNetworkSubnets;
  }


  public NetworkConfiguration localNetworkAddresses(@javax.annotation.Nullable List<String> localNetworkAddresses) {
    this.localNetworkAddresses = localNetworkAddresses;
    return this;
  }

  public NetworkConfiguration addLocalNetworkAddressesItem(String localNetworkAddressesItem) {
    if (this.localNetworkAddresses == null) {
      this.localNetworkAddresses = new ArrayList<>();
    }
    this.localNetworkAddresses.add(localNetworkAddressesItem);
    return this;
  }

  /**
   * Gets or sets the interface addresses which Jellyfin will bind to. If empty, all interfaces will be used.
   * @return localNetworkAddresses
   */
  @javax.annotation.Nullable
  public List<String> getLocalNetworkAddresses() {
    return localNetworkAddresses;
  }

  public void setLocalNetworkAddresses(@javax.annotation.Nullable List<String> localNetworkAddresses) {
    this.localNetworkAddresses = localNetworkAddresses;
  }


  public NetworkConfiguration knownProxies(@javax.annotation.Nullable List<String> knownProxies) {
    this.knownProxies = knownProxies;
    return this;
  }

  public NetworkConfiguration addKnownProxiesItem(String knownProxiesItem) {
    if (this.knownProxies == null) {
      this.knownProxies = new ArrayList<>();
    }
    this.knownProxies.add(knownProxiesItem);
    return this;
  }

  /**
   * Gets or sets the known proxies. If the proxy is a network, it&#39;s added to the KnownNetworks.
   * @return knownProxies
   */
  @javax.annotation.Nullable
  public List<String> getKnownProxies() {
    return knownProxies;
  }

  public void setKnownProxies(@javax.annotation.Nullable List<String> knownProxies) {
    this.knownProxies = knownProxies;
  }


  public NetworkConfiguration enablePublishedServerUriByRequest(@javax.annotation.Nullable Boolean enablePublishedServerUriByRequest) {
    this.enablePublishedServerUriByRequest = enablePublishedServerUriByRequest;
    return this;
  }

  /**
   * Gets or sets a value indicating whether the published server uri is based on information in HTTP requests.
   * @return enablePublishedServerUriByRequest
   */
  @javax.annotation.Nullable
  public Boolean getEnablePublishedServerUriByRequest() {
    return enablePublishedServerUriByRequest;
  }

  public void setEnablePublishedServerUriByRequest(@javax.annotation.Nullable Boolean enablePublishedServerUriByRequest) {
    this.enablePublishedServerUriByRequest = enablePublishedServerUriByRequest;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NetworkConfiguration networkConfiguration = (NetworkConfiguration) o;
    return Objects.equals(this.requireHttps, networkConfiguration.requireHttps) &&
        Objects.equals(this.certificatePath, networkConfiguration.certificatePath) &&
        Objects.equals(this.certificatePassword, networkConfiguration.certificatePassword) &&
        Objects.equals(this.baseUrl, networkConfiguration.baseUrl) &&
        Objects.equals(this.publicHttpsPort, networkConfiguration.publicHttpsPort) &&
        Objects.equals(this.httpServerPortNumber, networkConfiguration.httpServerPortNumber) &&
        Objects.equals(this.httpsPortNumber, networkConfiguration.httpsPortNumber) &&
        Objects.equals(this.enableHttps, networkConfiguration.enableHttps) &&
        Objects.equals(this.publicPort, networkConfiguration.publicPort) &&
        Objects.equals(this.upnPCreateHttpPortMap, networkConfiguration.upnPCreateHttpPortMap) &&
        Objects.equals(this.udPPortRange, networkConfiguration.udPPortRange) &&
        Objects.equals(this.enableIPV6, networkConfiguration.enableIPV6) &&
        Objects.equals(this.enableIPV4, networkConfiguration.enableIPV4) &&
        Objects.equals(this.enableSSDPTracing, networkConfiguration.enableSSDPTracing) &&
        Objects.equals(this.ssDPTracingFilter, networkConfiguration.ssDPTracingFilter) &&
        Objects.equals(this.udPSendCount, networkConfiguration.udPSendCount) &&
        Objects.equals(this.udPSendDelay, networkConfiguration.udPSendDelay) &&
        Objects.equals(this.ignoreVirtualInterfaces, networkConfiguration.ignoreVirtualInterfaces) &&
        Objects.equals(this.virtualInterfaceNames, networkConfiguration.virtualInterfaceNames) &&
        Objects.equals(this.gatewayMonitorPeriod, networkConfiguration.gatewayMonitorPeriod) &&
        Objects.equals(this.enableMultiSocketBinding, networkConfiguration.enableMultiSocketBinding) &&
        Objects.equals(this.trustAllIP6Interfaces, networkConfiguration.trustAllIP6Interfaces) &&
        Objects.equals(this.hdHomerunPortRange, networkConfiguration.hdHomerunPortRange) &&
        Objects.equals(this.publishedServerUriBySubnet, networkConfiguration.publishedServerUriBySubnet) &&
        Objects.equals(this.autoDiscoveryTracing, networkConfiguration.autoDiscoveryTracing) &&
        Objects.equals(this.autoDiscovery, networkConfiguration.autoDiscovery) &&
        Objects.equals(this.remoteIPFilter, networkConfiguration.remoteIPFilter) &&
        Objects.equals(this.isRemoteIPFilterBlacklist, networkConfiguration.isRemoteIPFilterBlacklist) &&
        Objects.equals(this.enableUPnP, networkConfiguration.enableUPnP) &&
        Objects.equals(this.enableRemoteAccess, networkConfiguration.enableRemoteAccess) &&
        Objects.equals(this.localNetworkSubnets, networkConfiguration.localNetworkSubnets) &&
        Objects.equals(this.localNetworkAddresses, networkConfiguration.localNetworkAddresses) &&
        Objects.equals(this.knownProxies, networkConfiguration.knownProxies) &&
        Objects.equals(this.enablePublishedServerUriByRequest, networkConfiguration.enablePublishedServerUriByRequest);
  }

  @Override
  public int hashCode() {
    return Objects.hash(requireHttps, certificatePath, certificatePassword, baseUrl, publicHttpsPort, httpServerPortNumber, httpsPortNumber, enableHttps, publicPort, upnPCreateHttpPortMap, udPPortRange, enableIPV6, enableIPV4, enableSSDPTracing, ssDPTracingFilter, udPSendCount, udPSendDelay, ignoreVirtualInterfaces, virtualInterfaceNames, gatewayMonitorPeriod, enableMultiSocketBinding, trustAllIP6Interfaces, hdHomerunPortRange, publishedServerUriBySubnet, autoDiscoveryTracing, autoDiscovery, remoteIPFilter, isRemoteIPFilterBlacklist, enableUPnP, enableRemoteAccess, localNetworkSubnets, localNetworkAddresses, knownProxies, enablePublishedServerUriByRequest);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NetworkConfiguration {\n");
    sb.append("    requireHttps: ").append(toIndentedString(requireHttps)).append("\n");
    sb.append("    certificatePath: ").append(toIndentedString(certificatePath)).append("\n");
    sb.append("    certificatePassword: ").append(toIndentedString(certificatePassword)).append("\n");
    sb.append("    baseUrl: ").append(toIndentedString(baseUrl)).append("\n");
    sb.append("    publicHttpsPort: ").append(toIndentedString(publicHttpsPort)).append("\n");
    sb.append("    httpServerPortNumber: ").append(toIndentedString(httpServerPortNumber)).append("\n");
    sb.append("    httpsPortNumber: ").append(toIndentedString(httpsPortNumber)).append("\n");
    sb.append("    enableHttps: ").append(toIndentedString(enableHttps)).append("\n");
    sb.append("    publicPort: ").append(toIndentedString(publicPort)).append("\n");
    sb.append("    upnPCreateHttpPortMap: ").append(toIndentedString(upnPCreateHttpPortMap)).append("\n");
    sb.append("    udPPortRange: ").append(toIndentedString(udPPortRange)).append("\n");
    sb.append("    enableIPV6: ").append(toIndentedString(enableIPV6)).append("\n");
    sb.append("    enableIPV4: ").append(toIndentedString(enableIPV4)).append("\n");
    sb.append("    enableSSDPTracing: ").append(toIndentedString(enableSSDPTracing)).append("\n");
    sb.append("    ssDPTracingFilter: ").append(toIndentedString(ssDPTracingFilter)).append("\n");
    sb.append("    udPSendCount: ").append(toIndentedString(udPSendCount)).append("\n");
    sb.append("    udPSendDelay: ").append(toIndentedString(udPSendDelay)).append("\n");
    sb.append("    ignoreVirtualInterfaces: ").append(toIndentedString(ignoreVirtualInterfaces)).append("\n");
    sb.append("    virtualInterfaceNames: ").append(toIndentedString(virtualInterfaceNames)).append("\n");
    sb.append("    gatewayMonitorPeriod: ").append(toIndentedString(gatewayMonitorPeriod)).append("\n");
    sb.append("    enableMultiSocketBinding: ").append(toIndentedString(enableMultiSocketBinding)).append("\n");
    sb.append("    trustAllIP6Interfaces: ").append(toIndentedString(trustAllIP6Interfaces)).append("\n");
    sb.append("    hdHomerunPortRange: ").append(toIndentedString(hdHomerunPortRange)).append("\n");
    sb.append("    publishedServerUriBySubnet: ").append(toIndentedString(publishedServerUriBySubnet)).append("\n");
    sb.append("    autoDiscoveryTracing: ").append(toIndentedString(autoDiscoveryTracing)).append("\n");
    sb.append("    autoDiscovery: ").append(toIndentedString(autoDiscovery)).append("\n");
    sb.append("    remoteIPFilter: ").append(toIndentedString(remoteIPFilter)).append("\n");
    sb.append("    isRemoteIPFilterBlacklist: ").append(toIndentedString(isRemoteIPFilterBlacklist)).append("\n");
    sb.append("    enableUPnP: ").append(toIndentedString(enableUPnP)).append("\n");
    sb.append("    enableRemoteAccess: ").append(toIndentedString(enableRemoteAccess)).append("\n");
    sb.append("    localNetworkSubnets: ").append(toIndentedString(localNetworkSubnets)).append("\n");
    sb.append("    localNetworkAddresses: ").append(toIndentedString(localNetworkAddresses)).append("\n");
    sb.append("    knownProxies: ").append(toIndentedString(knownProxies)).append("\n");
    sb.append("    enablePublishedServerUriByRequest: ").append(toIndentedString(enablePublishedServerUriByRequest)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("RequireHttps");
    openapiFields.add("CertificatePath");
    openapiFields.add("CertificatePassword");
    openapiFields.add("BaseUrl");
    openapiFields.add("PublicHttpsPort");
    openapiFields.add("HttpServerPortNumber");
    openapiFields.add("HttpsPortNumber");
    openapiFields.add("EnableHttps");
    openapiFields.add("PublicPort");
    openapiFields.add("UPnPCreateHttpPortMap");
    openapiFields.add("UDPPortRange");
    openapiFields.add("EnableIPV6");
    openapiFields.add("EnableIPV4");
    openapiFields.add("EnableSSDPTracing");
    openapiFields.add("SSDPTracingFilter");
    openapiFields.add("UDPSendCount");
    openapiFields.add("UDPSendDelay");
    openapiFields.add("IgnoreVirtualInterfaces");
    openapiFields.add("VirtualInterfaceNames");
    openapiFields.add("GatewayMonitorPeriod");
    openapiFields.add("EnableMultiSocketBinding");
    openapiFields.add("TrustAllIP6Interfaces");
    openapiFields.add("HDHomerunPortRange");
    openapiFields.add("PublishedServerUriBySubnet");
    openapiFields.add("AutoDiscoveryTracing");
    openapiFields.add("AutoDiscovery");
    openapiFields.add("RemoteIPFilter");
    openapiFields.add("IsRemoteIPFilterBlacklist");
    openapiFields.add("EnableUPnP");
    openapiFields.add("EnableRemoteAccess");
    openapiFields.add("LocalNetworkSubnets");
    openapiFields.add("LocalNetworkAddresses");
    openapiFields.add("KnownProxies");
    openapiFields.add("EnablePublishedServerUriByRequest");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NetworkConfiguration
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NetworkConfiguration.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NetworkConfiguration is not found in the empty JSON string", NetworkConfiguration.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NetworkConfiguration.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NetworkConfiguration` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("CertificatePath") != null && !jsonObj.get("CertificatePath").isJsonNull()) && !jsonObj.get("CertificatePath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CertificatePath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CertificatePath").toString()));
      }
      if ((jsonObj.get("CertificatePassword") != null && !jsonObj.get("CertificatePassword").isJsonNull()) && !jsonObj.get("CertificatePassword").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CertificatePassword` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CertificatePassword").toString()));
      }
      if ((jsonObj.get("BaseUrl") != null && !jsonObj.get("BaseUrl").isJsonNull()) && !jsonObj.get("BaseUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `BaseUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("BaseUrl").toString()));
      }
      if ((jsonObj.get("UDPPortRange") != null && !jsonObj.get("UDPPortRange").isJsonNull()) && !jsonObj.get("UDPPortRange").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `UDPPortRange` to be a primitive type in the JSON string but got `%s`", jsonObj.get("UDPPortRange").toString()));
      }
      if ((jsonObj.get("SSDPTracingFilter") != null && !jsonObj.get("SSDPTracingFilter").isJsonNull()) && !jsonObj.get("SSDPTracingFilter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SSDPTracingFilter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SSDPTracingFilter").toString()));
      }
      if ((jsonObj.get("VirtualInterfaceNames") != null && !jsonObj.get("VirtualInterfaceNames").isJsonNull()) && !jsonObj.get("VirtualInterfaceNames").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `VirtualInterfaceNames` to be a primitive type in the JSON string but got `%s`", jsonObj.get("VirtualInterfaceNames").toString()));
      }
      if ((jsonObj.get("HDHomerunPortRange") != null && !jsonObj.get("HDHomerunPortRange").isJsonNull()) && !jsonObj.get("HDHomerunPortRange").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `HDHomerunPortRange` to be a primitive type in the JSON string but got `%s`", jsonObj.get("HDHomerunPortRange").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("PublishedServerUriBySubnet") != null && !jsonObj.get("PublishedServerUriBySubnet").isJsonNull() && !jsonObj.get("PublishedServerUriBySubnet").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `PublishedServerUriBySubnet` to be an array in the JSON string but got `%s`", jsonObj.get("PublishedServerUriBySubnet").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("RemoteIPFilter") != null && !jsonObj.get("RemoteIPFilter").isJsonNull() && !jsonObj.get("RemoteIPFilter").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `RemoteIPFilter` to be an array in the JSON string but got `%s`", jsonObj.get("RemoteIPFilter").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("LocalNetworkSubnets") != null && !jsonObj.get("LocalNetworkSubnets").isJsonNull() && !jsonObj.get("LocalNetworkSubnets").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `LocalNetworkSubnets` to be an array in the JSON string but got `%s`", jsonObj.get("LocalNetworkSubnets").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("LocalNetworkAddresses") != null && !jsonObj.get("LocalNetworkAddresses").isJsonNull() && !jsonObj.get("LocalNetworkAddresses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `LocalNetworkAddresses` to be an array in the JSON string but got `%s`", jsonObj.get("LocalNetworkAddresses").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("KnownProxies") != null && !jsonObj.get("KnownProxies").isJsonNull() && !jsonObj.get("KnownProxies").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `KnownProxies` to be an array in the JSON string but got `%s`", jsonObj.get("KnownProxies").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NetworkConfiguration.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NetworkConfiguration' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NetworkConfiguration> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NetworkConfiguration.class));

       return (TypeAdapter<T>) new TypeAdapter<NetworkConfiguration>() {
           @Override
           public void write(JsonWriter out, NetworkConfiguration value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NetworkConfiguration read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NetworkConfiguration given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NetworkConfiguration
   * @throws IOException if the JSON string is invalid with respect to NetworkConfiguration
   */
  public static NetworkConfiguration fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NetworkConfiguration.class);
  }

  /**
   * Convert an instance of NetworkConfiguration to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

