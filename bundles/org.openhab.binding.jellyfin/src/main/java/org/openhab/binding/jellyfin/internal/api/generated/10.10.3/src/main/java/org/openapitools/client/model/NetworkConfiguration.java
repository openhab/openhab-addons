/*
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.10.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines the MediaBrowser.Common.Net.NetworkConfiguration.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-12-27T20:32:56.699980679+01:00[Europe/Zurich]", comments = "Generator version: 7.10.0")
public class NetworkConfiguration {
  public static final String SERIALIZED_NAME_BASE_URL = "BaseUrl";
  @SerializedName(SERIALIZED_NAME_BASE_URL)
  @javax.annotation.Nullable
  private String baseUrl;

  public static final String SERIALIZED_NAME_ENABLE_HTTPS = "EnableHttps";
  @SerializedName(SERIALIZED_NAME_ENABLE_HTTPS)
  @javax.annotation.Nullable
  private Boolean enableHttps;

  public static final String SERIALIZED_NAME_REQUIRE_HTTPS = "RequireHttps";
  @SerializedName(SERIALIZED_NAME_REQUIRE_HTTPS)
  @javax.annotation.Nullable
  private Boolean requireHttps;

  public static final String SERIALIZED_NAME_CERTIFICATE_PATH = "CertificatePath";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_PATH)
  @javax.annotation.Nullable
  private String certificatePath;

  public static final String SERIALIZED_NAME_CERTIFICATE_PASSWORD = "CertificatePassword";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_PASSWORD)
  @javax.annotation.Nullable
  private String certificatePassword;

  public static final String SERIALIZED_NAME_INTERNAL_HTTP_PORT = "InternalHttpPort";
  @SerializedName(SERIALIZED_NAME_INTERNAL_HTTP_PORT)
  @javax.annotation.Nullable
  private Integer internalHttpPort;

  public static final String SERIALIZED_NAME_INTERNAL_HTTPS_PORT = "InternalHttpsPort";
  @SerializedName(SERIALIZED_NAME_INTERNAL_HTTPS_PORT)
  @javax.annotation.Nullable
  private Integer internalHttpsPort;

  public static final String SERIALIZED_NAME_PUBLIC_HTTP_PORT = "PublicHttpPort";
  @SerializedName(SERIALIZED_NAME_PUBLIC_HTTP_PORT)
  @javax.annotation.Nullable
  private Integer publicHttpPort;

  public static final String SERIALIZED_NAME_PUBLIC_HTTPS_PORT = "PublicHttpsPort";
  @SerializedName(SERIALIZED_NAME_PUBLIC_HTTPS_PORT)
  @javax.annotation.Nullable
  private Integer publicHttpsPort;

  public static final String SERIALIZED_NAME_AUTO_DISCOVERY = "AutoDiscovery";
  @SerializedName(SERIALIZED_NAME_AUTO_DISCOVERY)
  @javax.annotation.Nullable
  private Boolean autoDiscovery;

  public static final String SERIALIZED_NAME_ENABLE_U_PN_P = "EnableUPnP";
  @SerializedName(SERIALIZED_NAME_ENABLE_U_PN_P)
  @javax.annotation.Nullable
  private Boolean enableUPnP;

  public static final String SERIALIZED_NAME_ENABLE_I_PV4 = "EnableIPv4";
  @SerializedName(SERIALIZED_NAME_ENABLE_I_PV4)
  @javax.annotation.Nullable
  private Boolean enableIPv4;

  public static final String SERIALIZED_NAME_ENABLE_I_PV6 = "EnableIPv6";
  @SerializedName(SERIALIZED_NAME_ENABLE_I_PV6)
  @javax.annotation.Nullable
  private Boolean enableIPv6;

  public static final String SERIALIZED_NAME_ENABLE_REMOTE_ACCESS = "EnableRemoteAccess";
  @SerializedName(SERIALIZED_NAME_ENABLE_REMOTE_ACCESS)
  @javax.annotation.Nullable
  private Boolean enableRemoteAccess;

  public static final String SERIALIZED_NAME_LOCAL_NETWORK_SUBNETS = "LocalNetworkSubnets";
  @SerializedName(SERIALIZED_NAME_LOCAL_NETWORK_SUBNETS)
  @javax.annotation.Nullable
  private List<String> localNetworkSubnets = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOCAL_NETWORK_ADDRESSES = "LocalNetworkAddresses";
  @SerializedName(SERIALIZED_NAME_LOCAL_NETWORK_ADDRESSES)
  @javax.annotation.Nullable
  private List<String> localNetworkAddresses = new ArrayList<>();

  public static final String SERIALIZED_NAME_KNOWN_PROXIES = "KnownProxies";
  @SerializedName(SERIALIZED_NAME_KNOWN_PROXIES)
  @javax.annotation.Nullable
  private List<String> knownProxies = new ArrayList<>();

  public static final String SERIALIZED_NAME_IGNORE_VIRTUAL_INTERFACES = "IgnoreVirtualInterfaces";
  @SerializedName(SERIALIZED_NAME_IGNORE_VIRTUAL_INTERFACES)
  @javax.annotation.Nullable
  private Boolean ignoreVirtualInterfaces;

  public static final String SERIALIZED_NAME_VIRTUAL_INTERFACE_NAMES = "VirtualInterfaceNames";
  @SerializedName(SERIALIZED_NAME_VIRTUAL_INTERFACE_NAMES)
  @javax.annotation.Nullable
  private List<String> virtualInterfaceNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_ENABLE_PUBLISHED_SERVER_URI_BY_REQUEST = "EnablePublishedServerUriByRequest";
  @SerializedName(SERIALIZED_NAME_ENABLE_PUBLISHED_SERVER_URI_BY_REQUEST)
  @javax.annotation.Nullable
  private Boolean enablePublishedServerUriByRequest;

  public static final String SERIALIZED_NAME_PUBLISHED_SERVER_URI_BY_SUBNET = "PublishedServerUriBySubnet";
  @SerializedName(SERIALIZED_NAME_PUBLISHED_SERVER_URI_BY_SUBNET)
  @javax.annotation.Nullable
  private List<String> publishedServerUriBySubnet = new ArrayList<>();

  public static final String SERIALIZED_NAME_REMOTE_I_P_FILTER = "RemoteIPFilter";
  @SerializedName(SERIALIZED_NAME_REMOTE_I_P_FILTER)
  @javax.annotation.Nullable
  private List<String> remoteIPFilter = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_REMOTE_I_P_FILTER_BLACKLIST = "IsRemoteIPFilterBlacklist";
  @SerializedName(SERIALIZED_NAME_IS_REMOTE_I_P_FILTER_BLACKLIST)
  @javax.annotation.Nullable
  private Boolean isRemoteIPFilterBlacklist;

  public NetworkConfiguration() {
  }

  public NetworkConfiguration baseUrl(@javax.annotation.Nullable String baseUrl) {
    this.baseUrl = baseUrl;
    return this;
  }

  /**
   * Gets or sets a value used to specify the URL prefix that your Jellyfin instance can be accessed at.
   * @return baseUrl
   */
  @javax.annotation.Nullable
  public String getBaseUrl() {
    return baseUrl;
  }

  public void setBaseUrl(@javax.annotation.Nullable String baseUrl) {
    this.baseUrl = baseUrl;
  }


  public NetworkConfiguration enableHttps(@javax.annotation.Nullable Boolean enableHttps) {
    this.enableHttps = enableHttps;
    return this;
  }

  /**
   * Gets or sets a value indicating whether to use HTTPS.
   * @return enableHttps
   */
  @javax.annotation.Nullable
  public Boolean getEnableHttps() {
    return enableHttps;
  }

  public void setEnableHttps(@javax.annotation.Nullable Boolean enableHttps) {
    this.enableHttps = enableHttps;
  }


  public NetworkConfiguration requireHttps(@javax.annotation.Nullable Boolean requireHttps) {
    this.requireHttps = requireHttps;
    return this;
  }

  /**
   * Gets or sets a value indicating whether the server should force connections over HTTPS.
   * @return requireHttps
   */
  @javax.annotation.Nullable
  public Boolean getRequireHttps() {
    return requireHttps;
  }

  public void setRequireHttps(@javax.annotation.Nullable Boolean requireHttps) {
    this.requireHttps = requireHttps;
  }


  public NetworkConfiguration certificatePath(@javax.annotation.Nullable String certificatePath) {
    this.certificatePath = certificatePath;
    return this;
  }

  /**
   * Gets or sets the filesystem path of an X.509 certificate to use for SSL.
   * @return certificatePath
   */
  @javax.annotation.Nullable
  public String getCertificatePath() {
    return certificatePath;
  }

  public void setCertificatePath(@javax.annotation.Nullable String certificatePath) {
    this.certificatePath = certificatePath;
  }


  public NetworkConfiguration certificatePassword(@javax.annotation.Nullable String certificatePassword) {
    this.certificatePassword = certificatePassword;
    return this;
  }

  /**
   * Gets or sets the password required to access the X.509 certificate data in the file specified by MediaBrowser.Common.Net.NetworkConfiguration.CertificatePath.
   * @return certificatePassword
   */
  @javax.annotation.Nullable
  public String getCertificatePassword() {
    return certificatePassword;
  }

  public void setCertificatePassword(@javax.annotation.Nullable String certificatePassword) {
    this.certificatePassword = certificatePassword;
  }


  public NetworkConfiguration internalHttpPort(@javax.annotation.Nullable Integer internalHttpPort) {
    this.internalHttpPort = internalHttpPort;
    return this;
  }

  /**
   * Gets or sets the internal HTTP server port.
   * @return internalHttpPort
   */
  @javax.annotation.Nullable
  public Integer getInternalHttpPort() {
    return internalHttpPort;
  }

  public void setInternalHttpPort(@javax.annotation.Nullable Integer internalHttpPort) {
    this.internalHttpPort = internalHttpPort;
  }


  public NetworkConfiguration internalHttpsPort(@javax.annotation.Nullable Integer internalHttpsPort) {
    this.internalHttpsPort = internalHttpsPort;
    return this;
  }

  /**
   * Gets or sets the internal HTTPS server port.
   * @return internalHttpsPort
   */
  @javax.annotation.Nullable
  public Integer getInternalHttpsPort() {
    return internalHttpsPort;
  }

  public void setInternalHttpsPort(@javax.annotation.Nullable Integer internalHttpsPort) {
    this.internalHttpsPort = internalHttpsPort;
  }


  public NetworkConfiguration publicHttpPort(@javax.annotation.Nullable Integer publicHttpPort) {
    this.publicHttpPort = publicHttpPort;
    return this;
  }

  /**
   * Gets or sets the public HTTP port.
   * @return publicHttpPort
   */
  @javax.annotation.Nullable
  public Integer getPublicHttpPort() {
    return publicHttpPort;
  }

  public void setPublicHttpPort(@javax.annotation.Nullable Integer publicHttpPort) {
    this.publicHttpPort = publicHttpPort;
  }


  public NetworkConfiguration publicHttpsPort(@javax.annotation.Nullable Integer publicHttpsPort) {
    this.publicHttpsPort = publicHttpsPort;
    return this;
  }

  /**
   * Gets or sets the public HTTPS port.
   * @return publicHttpsPort
   */
  @javax.annotation.Nullable
  public Integer getPublicHttpsPort() {
    return publicHttpsPort;
  }

  public void setPublicHttpsPort(@javax.annotation.Nullable Integer publicHttpsPort) {
    this.publicHttpsPort = publicHttpsPort;
  }


  public NetworkConfiguration autoDiscovery(@javax.annotation.Nullable Boolean autoDiscovery) {
    this.autoDiscovery = autoDiscovery;
    return this;
  }

  /**
   * Gets or sets a value indicating whether Autodiscovery is enabled.
   * @return autoDiscovery
   */
  @javax.annotation.Nullable
  public Boolean getAutoDiscovery() {
    return autoDiscovery;
  }

  public void setAutoDiscovery(@javax.annotation.Nullable Boolean autoDiscovery) {
    this.autoDiscovery = autoDiscovery;
  }


  public NetworkConfiguration enableUPnP(@javax.annotation.Nullable Boolean enableUPnP) {
    this.enableUPnP = enableUPnP;
    return this;
  }

  /**
   * Gets or sets a value indicating whether to enable automatic port forwarding.
   * @return enableUPnP
   */
  @javax.annotation.Nullable
  public Boolean getEnableUPnP() {
    return enableUPnP;
  }

  public void setEnableUPnP(@javax.annotation.Nullable Boolean enableUPnP) {
    this.enableUPnP = enableUPnP;
  }


  public NetworkConfiguration enableIPv4(@javax.annotation.Nullable Boolean enableIPv4) {
    this.enableIPv4 = enableIPv4;
    return this;
  }

  /**
   * Gets or sets a value indicating whether IPv6 is enabled.
   * @return enableIPv4
   */
  @javax.annotation.Nullable
  public Boolean getEnableIPv4() {
    return enableIPv4;
  }

  public void setEnableIPv4(@javax.annotation.Nullable Boolean enableIPv4) {
    this.enableIPv4 = enableIPv4;
  }


  public NetworkConfiguration enableIPv6(@javax.annotation.Nullable Boolean enableIPv6) {
    this.enableIPv6 = enableIPv6;
    return this;
  }

  /**
   * Gets or sets a value indicating whether IPv6 is enabled.
   * @return enableIPv6
   */
  @javax.annotation.Nullable
  public Boolean getEnableIPv6() {
    return enableIPv6;
  }

  public void setEnableIPv6(@javax.annotation.Nullable Boolean enableIPv6) {
    this.enableIPv6 = enableIPv6;
  }


  public NetworkConfiguration enableRemoteAccess(@javax.annotation.Nullable Boolean enableRemoteAccess) {
    this.enableRemoteAccess = enableRemoteAccess;
    return this;
  }

  /**
   * Gets or sets a value indicating whether access from outside of the LAN is permitted.
   * @return enableRemoteAccess
   */
  @javax.annotation.Nullable
  public Boolean getEnableRemoteAccess() {
    return enableRemoteAccess;
  }

  public void setEnableRemoteAccess(@javax.annotation.Nullable Boolean enableRemoteAccess) {
    this.enableRemoteAccess = enableRemoteAccess;
  }


  public NetworkConfiguration localNetworkSubnets(@javax.annotation.Nullable List<String> localNetworkSubnets) {
    this.localNetworkSubnets = localNetworkSubnets;
    return this;
  }

  public NetworkConfiguration addLocalNetworkSubnetsItem(String localNetworkSubnetsItem) {
    if (this.localNetworkSubnets == null) {
      this.localNetworkSubnets = new ArrayList<>();
    }
    this.localNetworkSubnets.add(localNetworkSubnetsItem);
    return this;
  }

  /**
   * Gets or sets the subnets that are deemed to make up the LAN.
   * @return localNetworkSubnets
   */
  @javax.annotation.Nullable
  public List<String> getLocalNetworkSubnets() {
    return localNetworkSubnets;
  }

  public void setLocalNetworkSubnets(@javax.annotation.Nullable List<String> localNetworkSubnets) {
    this.localNetworkSubnets = localNetworkSubnets;
  }


  public NetworkConfiguration localNetworkAddresses(@javax.annotation.Nullable List<String> localNetworkAddresses) {
    this.localNetworkAddresses = localNetworkAddresses;
    return this;
  }

  public NetworkConfiguration addLocalNetworkAddressesItem(String localNetworkAddressesItem) {
    if (this.localNetworkAddresses == null) {
      this.localNetworkAddresses = new ArrayList<>();
    }
    this.localNetworkAddresses.add(localNetworkAddressesItem);
    return this;
  }

  /**
   * Gets or sets the interface addresses which Jellyfin will bind to. If empty, all interfaces will be used.
   * @return localNetworkAddresses
   */
  @javax.annotation.Nullable
  public List<String> getLocalNetworkAddresses() {
    return localNetworkAddresses;
  }

  public void setLocalNetworkAddresses(@javax.annotation.Nullable List<String> localNetworkAddresses) {
    this.localNetworkAddresses = localNetworkAddresses;
  }


  public NetworkConfiguration knownProxies(@javax.annotation.Nullable List<String> knownProxies) {
    this.knownProxies = knownProxies;
    return this;
  }

  public NetworkConfiguration addKnownProxiesItem(String knownProxiesItem) {
    if (this.knownProxies == null) {
      this.knownProxies = new ArrayList<>();
    }
    this.knownProxies.add(knownProxiesItem);
    return this;
  }

  /**
   * Gets or sets the known proxies.
   * @return knownProxies
   */
  @javax.annotation.Nullable
  public List<String> getKnownProxies() {
    return knownProxies;
  }

  public void setKnownProxies(@javax.annotation.Nullable List<String> knownProxies) {
    this.knownProxies = knownProxies;
  }


  public NetworkConfiguration ignoreVirtualInterfaces(@javax.annotation.Nullable Boolean ignoreVirtualInterfaces) {
    this.ignoreVirtualInterfaces = ignoreVirtualInterfaces;
    return this;
  }

  /**
   * Gets or sets a value indicating whether address names that match MediaBrowser.Common.Net.NetworkConfiguration.VirtualInterfaceNames should be ignored for the purposes of binding.
   * @return ignoreVirtualInterfaces
   */
  @javax.annotation.Nullable
  public Boolean getIgnoreVirtualInterfaces() {
    return ignoreVirtualInterfaces;
  }

  public void setIgnoreVirtualInterfaces(@javax.annotation.Nullable Boolean ignoreVirtualInterfaces) {
    this.ignoreVirtualInterfaces = ignoreVirtualInterfaces;
  }


  public NetworkConfiguration virtualInterfaceNames(@javax.annotation.Nullable List<String> virtualInterfaceNames) {
    this.virtualInterfaceNames = virtualInterfaceNames;
    return this;
  }

  public NetworkConfiguration addVirtualInterfaceNamesItem(String virtualInterfaceNamesItem) {
    if (this.virtualInterfaceNames == null) {
      this.virtualInterfaceNames = new ArrayList<>();
    }
    this.virtualInterfaceNames.add(virtualInterfaceNamesItem);
    return this;
  }

  /**
   * Gets or sets a value indicating the interface name prefixes that should be ignored. The list can be comma separated and values are case-insensitive. &lt;seealso cref&#x3D;\&quot;P:MediaBrowser.Common.Net.NetworkConfiguration.IgnoreVirtualInterfaces\&quot; /&gt;.
   * @return virtualInterfaceNames
   */
  @javax.annotation.Nullable
  public List<String> getVirtualInterfaceNames() {
    return virtualInterfaceNames;
  }

  public void setVirtualInterfaceNames(@javax.annotation.Nullable List<String> virtualInterfaceNames) {
    this.virtualInterfaceNames = virtualInterfaceNames;
  }


  public NetworkConfiguration enablePublishedServerUriByRequest(@javax.annotation.Nullable Boolean enablePublishedServerUriByRequest) {
    this.enablePublishedServerUriByRequest = enablePublishedServerUriByRequest;
    return this;
  }

  /**
   * Gets or sets a value indicating whether the published server uri is based on information in HTTP requests.
   * @return enablePublishedServerUriByRequest
   */
  @javax.annotation.Nullable
  public Boolean getEnablePublishedServerUriByRequest() {
    return enablePublishedServerUriByRequest;
  }

  public void setEnablePublishedServerUriByRequest(@javax.annotation.Nullable Boolean enablePublishedServerUriByRequest) {
    this.enablePublishedServerUriByRequest = enablePublishedServerUriByRequest;
  }


  public NetworkConfiguration publishedServerUriBySubnet(@javax.annotation.Nullable List<String> publishedServerUriBySubnet) {
    this.publishedServerUriBySubnet = publishedServerUriBySubnet;
    return this;
  }

  public NetworkConfiguration addPublishedServerUriBySubnetItem(String publishedServerUriBySubnetItem) {
    if (this.publishedServerUriBySubnet == null) {
      this.publishedServerUriBySubnet = new ArrayList<>();
    }
    this.publishedServerUriBySubnet.add(publishedServerUriBySubnetItem);
    return this;
  }

  /**
   * Gets or sets the PublishedServerUriBySubnet  Gets or sets PublishedServerUri to advertise for specific subnets.
   * @return publishedServerUriBySubnet
   */
  @javax.annotation.Nullable
  public List<String> getPublishedServerUriBySubnet() {
    return publishedServerUriBySubnet;
  }

  public void setPublishedServerUriBySubnet(@javax.annotation.Nullable List<String> publishedServerUriBySubnet) {
    this.publishedServerUriBySubnet = publishedServerUriBySubnet;
  }


  public NetworkConfiguration remoteIPFilter(@javax.annotation.Nullable List<String> remoteIPFilter) {
    this.remoteIPFilter = remoteIPFilter;
    return this;
  }

  public NetworkConfiguration addRemoteIPFilterItem(String remoteIPFilterItem) {
    if (this.remoteIPFilter == null) {
      this.remoteIPFilter = new ArrayList<>();
    }
    this.remoteIPFilter.add(remoteIPFilterItem);
    return this;
  }

  /**
   * Gets or sets the filter for remote IP connectivity. Used in conjunction with &lt;seealso cref&#x3D;\&quot;P:MediaBrowser.Common.Net.NetworkConfiguration.IsRemoteIPFilterBlacklist\&quot; /&gt;.
   * @return remoteIPFilter
   */
  @javax.annotation.Nullable
  public List<String> getRemoteIPFilter() {
    return remoteIPFilter;
  }

  public void setRemoteIPFilter(@javax.annotation.Nullable List<String> remoteIPFilter) {
    this.remoteIPFilter = remoteIPFilter;
  }


  public NetworkConfiguration isRemoteIPFilterBlacklist(@javax.annotation.Nullable Boolean isRemoteIPFilterBlacklist) {
    this.isRemoteIPFilterBlacklist = isRemoteIPFilterBlacklist;
    return this;
  }

  /**
   * Gets or sets a value indicating whether &lt;seealso cref&#x3D;\&quot;P:MediaBrowser.Common.Net.NetworkConfiguration.RemoteIPFilter\&quot; /&gt; contains a blacklist or a whitelist. Default is a whitelist.
   * @return isRemoteIPFilterBlacklist
   */
  @javax.annotation.Nullable
  public Boolean getIsRemoteIPFilterBlacklist() {
    return isRemoteIPFilterBlacklist;
  }

  public void setIsRemoteIPFilterBlacklist(@javax.annotation.Nullable Boolean isRemoteIPFilterBlacklist) {
    this.isRemoteIPFilterBlacklist = isRemoteIPFilterBlacklist;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NetworkConfiguration networkConfiguration = (NetworkConfiguration) o;
    return Objects.equals(this.baseUrl, networkConfiguration.baseUrl) &&
        Objects.equals(this.enableHttps, networkConfiguration.enableHttps) &&
        Objects.equals(this.requireHttps, networkConfiguration.requireHttps) &&
        Objects.equals(this.certificatePath, networkConfiguration.certificatePath) &&
        Objects.equals(this.certificatePassword, networkConfiguration.certificatePassword) &&
        Objects.equals(this.internalHttpPort, networkConfiguration.internalHttpPort) &&
        Objects.equals(this.internalHttpsPort, networkConfiguration.internalHttpsPort) &&
        Objects.equals(this.publicHttpPort, networkConfiguration.publicHttpPort) &&
        Objects.equals(this.publicHttpsPort, networkConfiguration.publicHttpsPort) &&
        Objects.equals(this.autoDiscovery, networkConfiguration.autoDiscovery) &&
        Objects.equals(this.enableUPnP, networkConfiguration.enableUPnP) &&
        Objects.equals(this.enableIPv4, networkConfiguration.enableIPv4) &&
        Objects.equals(this.enableIPv6, networkConfiguration.enableIPv6) &&
        Objects.equals(this.enableRemoteAccess, networkConfiguration.enableRemoteAccess) &&
        Objects.equals(this.localNetworkSubnets, networkConfiguration.localNetworkSubnets) &&
        Objects.equals(this.localNetworkAddresses, networkConfiguration.localNetworkAddresses) &&
        Objects.equals(this.knownProxies, networkConfiguration.knownProxies) &&
        Objects.equals(this.ignoreVirtualInterfaces, networkConfiguration.ignoreVirtualInterfaces) &&
        Objects.equals(this.virtualInterfaceNames, networkConfiguration.virtualInterfaceNames) &&
        Objects.equals(this.enablePublishedServerUriByRequest, networkConfiguration.enablePublishedServerUriByRequest) &&
        Objects.equals(this.publishedServerUriBySubnet, networkConfiguration.publishedServerUriBySubnet) &&
        Objects.equals(this.remoteIPFilter, networkConfiguration.remoteIPFilter) &&
        Objects.equals(this.isRemoteIPFilterBlacklist, networkConfiguration.isRemoteIPFilterBlacklist);
  }

  @Override
  public int hashCode() {
    return Objects.hash(baseUrl, enableHttps, requireHttps, certificatePath, certificatePassword, internalHttpPort, internalHttpsPort, publicHttpPort, publicHttpsPort, autoDiscovery, enableUPnP, enableIPv4, enableIPv6, enableRemoteAccess, localNetworkSubnets, localNetworkAddresses, knownProxies, ignoreVirtualInterfaces, virtualInterfaceNames, enablePublishedServerUriByRequest, publishedServerUriBySubnet, remoteIPFilter, isRemoteIPFilterBlacklist);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NetworkConfiguration {\n");
    sb.append("    baseUrl: ").append(toIndentedString(baseUrl)).append("\n");
    sb.append("    enableHttps: ").append(toIndentedString(enableHttps)).append("\n");
    sb.append("    requireHttps: ").append(toIndentedString(requireHttps)).append("\n");
    sb.append("    certificatePath: ").append(toIndentedString(certificatePath)).append("\n");
    sb.append("    certificatePassword: ").append(toIndentedString(certificatePassword)).append("\n");
    sb.append("    internalHttpPort: ").append(toIndentedString(internalHttpPort)).append("\n");
    sb.append("    internalHttpsPort: ").append(toIndentedString(internalHttpsPort)).append("\n");
    sb.append("    publicHttpPort: ").append(toIndentedString(publicHttpPort)).append("\n");
    sb.append("    publicHttpsPort: ").append(toIndentedString(publicHttpsPort)).append("\n");
    sb.append("    autoDiscovery: ").append(toIndentedString(autoDiscovery)).append("\n");
    sb.append("    enableUPnP: ").append(toIndentedString(enableUPnP)).append("\n");
    sb.append("    enableIPv4: ").append(toIndentedString(enableIPv4)).append("\n");
    sb.append("    enableIPv6: ").append(toIndentedString(enableIPv6)).append("\n");
    sb.append("    enableRemoteAccess: ").append(toIndentedString(enableRemoteAccess)).append("\n");
    sb.append("    localNetworkSubnets: ").append(toIndentedString(localNetworkSubnets)).append("\n");
    sb.append("    localNetworkAddresses: ").append(toIndentedString(localNetworkAddresses)).append("\n");
    sb.append("    knownProxies: ").append(toIndentedString(knownProxies)).append("\n");
    sb.append("    ignoreVirtualInterfaces: ").append(toIndentedString(ignoreVirtualInterfaces)).append("\n");
    sb.append("    virtualInterfaceNames: ").append(toIndentedString(virtualInterfaceNames)).append("\n");
    sb.append("    enablePublishedServerUriByRequest: ").append(toIndentedString(enablePublishedServerUriByRequest)).append("\n");
    sb.append("    publishedServerUriBySubnet: ").append(toIndentedString(publishedServerUriBySubnet)).append("\n");
    sb.append("    remoteIPFilter: ").append(toIndentedString(remoteIPFilter)).append("\n");
    sb.append("    isRemoteIPFilterBlacklist: ").append(toIndentedString(isRemoteIPFilterBlacklist)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("BaseUrl");
    openapiFields.add("EnableHttps");
    openapiFields.add("RequireHttps");
    openapiFields.add("CertificatePath");
    openapiFields.add("CertificatePassword");
    openapiFields.add("InternalHttpPort");
    openapiFields.add("InternalHttpsPort");
    openapiFields.add("PublicHttpPort");
    openapiFields.add("PublicHttpsPort");
    openapiFields.add("AutoDiscovery");
    openapiFields.add("EnableUPnP");
    openapiFields.add("EnableIPv4");
    openapiFields.add("EnableIPv6");
    openapiFields.add("EnableRemoteAccess");
    openapiFields.add("LocalNetworkSubnets");
    openapiFields.add("LocalNetworkAddresses");
    openapiFields.add("KnownProxies");
    openapiFields.add("IgnoreVirtualInterfaces");
    openapiFields.add("VirtualInterfaceNames");
    openapiFields.add("EnablePublishedServerUriByRequest");
    openapiFields.add("PublishedServerUriBySubnet");
    openapiFields.add("RemoteIPFilter");
    openapiFields.add("IsRemoteIPFilterBlacklist");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NetworkConfiguration
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NetworkConfiguration.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NetworkConfiguration is not found in the empty JSON string", NetworkConfiguration.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NetworkConfiguration.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NetworkConfiguration` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("BaseUrl") != null && !jsonObj.get("BaseUrl").isJsonNull()) && !jsonObj.get("BaseUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `BaseUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("BaseUrl").toString()));
      }
      if ((jsonObj.get("CertificatePath") != null && !jsonObj.get("CertificatePath").isJsonNull()) && !jsonObj.get("CertificatePath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CertificatePath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CertificatePath").toString()));
      }
      if ((jsonObj.get("CertificatePassword") != null && !jsonObj.get("CertificatePassword").isJsonNull()) && !jsonObj.get("CertificatePassword").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CertificatePassword` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CertificatePassword").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("LocalNetworkSubnets") != null && !jsonObj.get("LocalNetworkSubnets").isJsonNull() && !jsonObj.get("LocalNetworkSubnets").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `LocalNetworkSubnets` to be an array in the JSON string but got `%s`", jsonObj.get("LocalNetworkSubnets").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("LocalNetworkAddresses") != null && !jsonObj.get("LocalNetworkAddresses").isJsonNull() && !jsonObj.get("LocalNetworkAddresses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `LocalNetworkAddresses` to be an array in the JSON string but got `%s`", jsonObj.get("LocalNetworkAddresses").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("KnownProxies") != null && !jsonObj.get("KnownProxies").isJsonNull() && !jsonObj.get("KnownProxies").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `KnownProxies` to be an array in the JSON string but got `%s`", jsonObj.get("KnownProxies").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("VirtualInterfaceNames") != null && !jsonObj.get("VirtualInterfaceNames").isJsonNull() && !jsonObj.get("VirtualInterfaceNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `VirtualInterfaceNames` to be an array in the JSON string but got `%s`", jsonObj.get("VirtualInterfaceNames").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("PublishedServerUriBySubnet") != null && !jsonObj.get("PublishedServerUriBySubnet").isJsonNull() && !jsonObj.get("PublishedServerUriBySubnet").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `PublishedServerUriBySubnet` to be an array in the JSON string but got `%s`", jsonObj.get("PublishedServerUriBySubnet").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("RemoteIPFilter") != null && !jsonObj.get("RemoteIPFilter").isJsonNull() && !jsonObj.get("RemoteIPFilter").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `RemoteIPFilter` to be an array in the JSON string but got `%s`", jsonObj.get("RemoteIPFilter").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NetworkConfiguration.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NetworkConfiguration' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NetworkConfiguration> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NetworkConfiguration.class));

       return (TypeAdapter<T>) new TypeAdapter<NetworkConfiguration>() {
           @Override
           public void write(JsonWriter out, NetworkConfiguration value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NetworkConfiguration read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NetworkConfiguration given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NetworkConfiguration
   * @throws IOException if the JSON string is invalid with respect to NetworkConfiguration
   */
  public static NetworkConfiguration fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NetworkConfiguration.class);
  }

  /**
   * Convert an instance of NetworkConfiguration to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

