/*
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.10.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.EncodingContext;
import java.io.File;
import org.openapitools.client.model.SubtitleDeliveryMethod;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DynamicHlsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DynamicHlsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DynamicHlsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getHlsAudioSegment
     * @param itemId The item id. (required)
     * @param playlistId The playlist id. (required)
     * @param segmentId The segment id. (required)
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param runtimeTicks The position of the requested segment in ticks. (required)
     * @param actualSegmentLengthTicks The length of the requested segment in ticks. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHlsAudioSegmentCall(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}"
            .replace("{" + "itemId" + "}", localVarApiClient.escapeString(itemId.toString()))
            .replace("{" + "playlistId" + "}", localVarApiClient.escapeString(playlistId.toString()))
            .replace("{" + "segmentId" + "}", localVarApiClient.escapeString(segmentId.toString()))
            .replace("{" + "container" + "}", localVarApiClient.escapeString(container.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (runtimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("runtimeTicks", runtimeTicks));
        }

        if (actualSegmentLengthTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("actualSegmentLengthTicks", actualSegmentLengthTicks));
        }

        if (_static != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("static", _static));
        }

        if (params != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("params", params));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (deviceProfileId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceProfileId", deviceProfileId));
        }

        if (playSessionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("playSessionId", playSessionId));
        }

        if (segmentContainer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentContainer", segmentContainer));
        }

        if (segmentLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentLength", segmentLength));
        }

        if (minSegments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minSegments", minSegments));
        }

        if (mediaSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mediaSourceId", mediaSourceId));
        }

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (audioCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioCodec", audioCodec));
        }

        if (enableAutoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAutoStreamCopy", enableAutoStreamCopy));
        }

        if (allowVideoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowVideoStreamCopy", allowVideoStreamCopy));
        }

        if (allowAudioStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowAudioStreamCopy", allowAudioStreamCopy));
        }

        if (breakOnNonKeyFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakOnNonKeyFrames", breakOnNonKeyFrames));
        }

        if (audioSampleRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioSampleRate", audioSampleRate));
        }

        if (maxAudioBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioBitDepth", maxAudioBitDepth));
        }

        if (maxStreamingBitrate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxStreamingBitrate", maxStreamingBitrate));
        }

        if (audioBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioBitRate", audioBitRate));
        }

        if (audioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioChannels", audioChannels));
        }

        if (maxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioChannels", maxAudioChannels));
        }

        if (profile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("profile", profile));
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (framerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("framerate", framerate));
        }

        if (maxFramerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFramerate", maxFramerate));
        }

        if (copyTimestamps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("copyTimestamps", copyTimestamps));
        }

        if (startTimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTimeTicks", startTimeTicks));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (videoBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoBitRate", videoBitRate));
        }

        if (subtitleStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleStreamIndex", subtitleStreamIndex));
        }

        if (subtitleMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleMethod", subtitleMethod));
        }

        if (maxRefFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRefFrames", maxRefFrames));
        }

        if (maxVideoBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxVideoBitDepth", maxVideoBitDepth));
        }

        if (requireAvc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireAvc", requireAvc));
        }

        if (deInterlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deInterlace", deInterlace));
        }

        if (requireNonAnamorphic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireNonAnamorphic", requireNonAnamorphic));
        }

        if (transcodingMaxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodingMaxAudioChannels", transcodingMaxAudioChannels));
        }

        if (cpuCoreLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cpuCoreLimit", cpuCoreLimit));
        }

        if (liveStreamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("liveStreamId", liveStreamId));
        }

        if (enableMpegtsM2TsMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMpegtsM2TsMode", enableMpegtsM2TsMode));
        }

        if (videoCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoCodec", videoCodec));
        }

        if (subtitleCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleCodec", subtitleCodec));
        }

        if (transcodeReasons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodeReasons", transcodeReasons));
        }

        if (audioStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioStreamIndex", audioStreamIndex));
        }

        if (videoStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoStreamIndex", videoStreamIndex));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (streamOptions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamOptions", streamOptions));
        }

        if (enableAudioVbrEncoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAudioVbrEncoding", enableAudioVbrEncoding));
        }

        final String[] localVarAccepts = {
            "audio/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "CustomAuthentication" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getHlsAudioSegmentValidateBeforeCall(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'itemId' is set
        if (itemId == null) {
            throw new ApiException("Missing the required parameter 'itemId' when calling getHlsAudioSegment(Async)");
        }

        // verify the required parameter 'playlistId' is set
        if (playlistId == null) {
            throw new ApiException("Missing the required parameter 'playlistId' when calling getHlsAudioSegment(Async)");
        }

        // verify the required parameter 'segmentId' is set
        if (segmentId == null) {
            throw new ApiException("Missing the required parameter 'segmentId' when calling getHlsAudioSegment(Async)");
        }

        // verify the required parameter 'container' is set
        if (container == null) {
            throw new ApiException("Missing the required parameter 'container' when calling getHlsAudioSegment(Async)");
        }

        // verify the required parameter 'runtimeTicks' is set
        if (runtimeTicks == null) {
            throw new ApiException("Missing the required parameter 'runtimeTicks' when calling getHlsAudioSegment(Async)");
        }

        // verify the required parameter 'actualSegmentLengthTicks' is set
        if (actualSegmentLengthTicks == null) {
            throw new ApiException("Missing the required parameter 'actualSegmentLengthTicks' when calling getHlsAudioSegment(Async)");
        }

        return getHlsAudioSegmentCall(itemId, playlistId, segmentId, container, runtimeTicks, actualSegmentLengthTicks, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, _callback);

    }

    /**
     * Gets a video stream using HTTP live streaming.
     * 
     * @param itemId The item id. (required)
     * @param playlistId The playlist id. (required)
     * @param segmentId The segment id. (required)
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param runtimeTicks The position of the requested segment in ticks. (required)
     * @param actualSegmentLengthTicks The length of the requested segment in ticks. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public File getHlsAudioSegment(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding) throws ApiException {
        ApiResponse<File> localVarResp = getHlsAudioSegmentWithHttpInfo(itemId, playlistId, segmentId, container, runtimeTicks, actualSegmentLengthTicks, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding);
        return localVarResp.getData();
    }

    /**
     * Gets a video stream using HTTP live streaming.
     * 
     * @param itemId The item id. (required)
     * @param playlistId The playlist id. (required)
     * @param segmentId The segment id. (required)
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param runtimeTicks The position of the requested segment in ticks. (required)
     * @param actualSegmentLengthTicks The length of the requested segment in ticks. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getHlsAudioSegmentWithHttpInfo(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding) throws ApiException {
        okhttp3.Call localVarCall = getHlsAudioSegmentValidateBeforeCall(itemId, playlistId, segmentId, container, runtimeTicks, actualSegmentLengthTicks, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a video stream using HTTP live streaming. (asynchronously)
     * 
     * @param itemId The item id. (required)
     * @param playlistId The playlist id. (required)
     * @param segmentId The segment id. (required)
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param runtimeTicks The position of the requested segment in ticks. (required)
     * @param actualSegmentLengthTicks The length of the requested segment in ticks. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHlsAudioSegmentAsync(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getHlsAudioSegmentValidateBeforeCall(itemId, playlistId, segmentId, container, runtimeTicks, actualSegmentLengthTicks, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getHlsVideoSegment
     * @param itemId The item id. (required)
     * @param playlistId The playlist id. (required)
     * @param segmentId The segment id. (required)
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param runtimeTicks The position of the requested segment in ticks. (required)
     * @param actualSegmentLengthTicks The length of the requested segment in ticks. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The desired segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHlsVideoSegmentCall(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}"
            .replace("{" + "itemId" + "}", localVarApiClient.escapeString(itemId.toString()))
            .replace("{" + "playlistId" + "}", localVarApiClient.escapeString(playlistId.toString()))
            .replace("{" + "segmentId" + "}", localVarApiClient.escapeString(segmentId.toString()))
            .replace("{" + "container" + "}", localVarApiClient.escapeString(container.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (runtimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("runtimeTicks", runtimeTicks));
        }

        if (actualSegmentLengthTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("actualSegmentLengthTicks", actualSegmentLengthTicks));
        }

        if (_static != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("static", _static));
        }

        if (params != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("params", params));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (deviceProfileId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceProfileId", deviceProfileId));
        }

        if (playSessionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("playSessionId", playSessionId));
        }

        if (segmentContainer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentContainer", segmentContainer));
        }

        if (segmentLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentLength", segmentLength));
        }

        if (minSegments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minSegments", minSegments));
        }

        if (mediaSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mediaSourceId", mediaSourceId));
        }

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (audioCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioCodec", audioCodec));
        }

        if (enableAutoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAutoStreamCopy", enableAutoStreamCopy));
        }

        if (allowVideoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowVideoStreamCopy", allowVideoStreamCopy));
        }

        if (allowAudioStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowAudioStreamCopy", allowAudioStreamCopy));
        }

        if (breakOnNonKeyFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakOnNonKeyFrames", breakOnNonKeyFrames));
        }

        if (audioSampleRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioSampleRate", audioSampleRate));
        }

        if (maxAudioBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioBitDepth", maxAudioBitDepth));
        }

        if (audioBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioBitRate", audioBitRate));
        }

        if (audioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioChannels", audioChannels));
        }

        if (maxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioChannels", maxAudioChannels));
        }

        if (profile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("profile", profile));
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (framerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("framerate", framerate));
        }

        if (maxFramerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFramerate", maxFramerate));
        }

        if (copyTimestamps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("copyTimestamps", copyTimestamps));
        }

        if (startTimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTimeTicks", startTimeTicks));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (maxWidth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxWidth", maxWidth));
        }

        if (maxHeight != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxHeight", maxHeight));
        }

        if (videoBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoBitRate", videoBitRate));
        }

        if (subtitleStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleStreamIndex", subtitleStreamIndex));
        }

        if (subtitleMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleMethod", subtitleMethod));
        }

        if (maxRefFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRefFrames", maxRefFrames));
        }

        if (maxVideoBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxVideoBitDepth", maxVideoBitDepth));
        }

        if (requireAvc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireAvc", requireAvc));
        }

        if (deInterlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deInterlace", deInterlace));
        }

        if (requireNonAnamorphic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireNonAnamorphic", requireNonAnamorphic));
        }

        if (transcodingMaxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodingMaxAudioChannels", transcodingMaxAudioChannels));
        }

        if (cpuCoreLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cpuCoreLimit", cpuCoreLimit));
        }

        if (liveStreamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("liveStreamId", liveStreamId));
        }

        if (enableMpegtsM2TsMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMpegtsM2TsMode", enableMpegtsM2TsMode));
        }

        if (videoCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoCodec", videoCodec));
        }

        if (subtitleCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleCodec", subtitleCodec));
        }

        if (transcodeReasons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodeReasons", transcodeReasons));
        }

        if (audioStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioStreamIndex", audioStreamIndex));
        }

        if (videoStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoStreamIndex", videoStreamIndex));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (streamOptions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamOptions", streamOptions));
        }

        if (enableAudioVbrEncoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAudioVbrEncoding", enableAudioVbrEncoding));
        }

        if (alwaysBurnInSubtitleWhenTranscoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("alwaysBurnInSubtitleWhenTranscoding", alwaysBurnInSubtitleWhenTranscoding));
        }

        final String[] localVarAccepts = {
            "video/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "CustomAuthentication" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getHlsVideoSegmentValidateBeforeCall(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'itemId' is set
        if (itemId == null) {
            throw new ApiException("Missing the required parameter 'itemId' when calling getHlsVideoSegment(Async)");
        }

        // verify the required parameter 'playlistId' is set
        if (playlistId == null) {
            throw new ApiException("Missing the required parameter 'playlistId' when calling getHlsVideoSegment(Async)");
        }

        // verify the required parameter 'segmentId' is set
        if (segmentId == null) {
            throw new ApiException("Missing the required parameter 'segmentId' when calling getHlsVideoSegment(Async)");
        }

        // verify the required parameter 'container' is set
        if (container == null) {
            throw new ApiException("Missing the required parameter 'container' when calling getHlsVideoSegment(Async)");
        }

        // verify the required parameter 'runtimeTicks' is set
        if (runtimeTicks == null) {
            throw new ApiException("Missing the required parameter 'runtimeTicks' when calling getHlsVideoSegment(Async)");
        }

        // verify the required parameter 'actualSegmentLengthTicks' is set
        if (actualSegmentLengthTicks == null) {
            throw new ApiException("Missing the required parameter 'actualSegmentLengthTicks' when calling getHlsVideoSegment(Async)");
        }

        return getHlsVideoSegmentCall(itemId, playlistId, segmentId, container, runtimeTicks, actualSegmentLengthTicks, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);

    }

    /**
     * Gets a video stream using HTTP live streaming.
     * 
     * @param itemId The item id. (required)
     * @param playlistId The playlist id. (required)
     * @param segmentId The segment id. (required)
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param runtimeTicks The position of the requested segment in ticks. (required)
     * @param actualSegmentLengthTicks The length of the requested segment in ticks. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The desired segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public File getHlsVideoSegment(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        ApiResponse<File> localVarResp = getHlsVideoSegmentWithHttpInfo(itemId, playlistId, segmentId, container, runtimeTicks, actualSegmentLengthTicks, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding);
        return localVarResp.getData();
    }

    /**
     * Gets a video stream using HTTP live streaming.
     * 
     * @param itemId The item id. (required)
     * @param playlistId The playlist id. (required)
     * @param segmentId The segment id. (required)
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param runtimeTicks The position of the requested segment in ticks. (required)
     * @param actualSegmentLengthTicks The length of the requested segment in ticks. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The desired segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getHlsVideoSegmentWithHttpInfo(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        okhttp3.Call localVarCall = getHlsVideoSegmentValidateBeforeCall(itemId, playlistId, segmentId, container, runtimeTicks, actualSegmentLengthTicks, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a video stream using HTTP live streaming. (asynchronously)
     * 
     * @param itemId The item id. (required)
     * @param playlistId The playlist id. (required)
     * @param segmentId The segment id. (required)
     * @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. (required)
     * @param runtimeTicks The position of the requested segment in ticks. (required)
     * @param actualSegmentLengthTicks The length of the requested segment in ticks. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The desired segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHlsVideoSegmentAsync(UUID itemId, String playlistId, Integer segmentId, String container, Long runtimeTicks, Long actualSegmentLengthTicks, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getHlsVideoSegmentValidateBeforeCall(itemId, playlistId, segmentId, container, runtimeTicks, actualSegmentLengthTicks, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getLiveHlsStream
     * @param itemId The item id. (required)
     * @param container The audio container. (optional)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param maxWidth Optional. The max width. (optional)
     * @param maxHeight Optional. The max height. (optional)
     * @param enableSubtitlesInManifest Optional. Whether to enable subtitles in the manifest. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Hls live stream retrieved. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLiveHlsStreamCall(UUID itemId, String container, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Integer maxWidth, Integer maxHeight, Boolean enableSubtitlesInManifest, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Videos/{itemId}/live.m3u8"
            .replace("{" + "itemId" + "}", localVarApiClient.escapeString(itemId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (container != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("container", container));
        }

        if (_static != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("static", _static));
        }

        if (params != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("params", params));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (deviceProfileId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceProfileId", deviceProfileId));
        }

        if (playSessionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("playSessionId", playSessionId));
        }

        if (segmentContainer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentContainer", segmentContainer));
        }

        if (segmentLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentLength", segmentLength));
        }

        if (minSegments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minSegments", minSegments));
        }

        if (mediaSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mediaSourceId", mediaSourceId));
        }

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (audioCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioCodec", audioCodec));
        }

        if (enableAutoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAutoStreamCopy", enableAutoStreamCopy));
        }

        if (allowVideoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowVideoStreamCopy", allowVideoStreamCopy));
        }

        if (allowAudioStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowAudioStreamCopy", allowAudioStreamCopy));
        }

        if (breakOnNonKeyFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakOnNonKeyFrames", breakOnNonKeyFrames));
        }

        if (audioSampleRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioSampleRate", audioSampleRate));
        }

        if (maxAudioBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioBitDepth", maxAudioBitDepth));
        }

        if (audioBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioBitRate", audioBitRate));
        }

        if (audioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioChannels", audioChannels));
        }

        if (maxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioChannels", maxAudioChannels));
        }

        if (profile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("profile", profile));
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (framerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("framerate", framerate));
        }

        if (maxFramerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFramerate", maxFramerate));
        }

        if (copyTimestamps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("copyTimestamps", copyTimestamps));
        }

        if (startTimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTimeTicks", startTimeTicks));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (videoBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoBitRate", videoBitRate));
        }

        if (subtitleStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleStreamIndex", subtitleStreamIndex));
        }

        if (subtitleMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleMethod", subtitleMethod));
        }

        if (maxRefFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRefFrames", maxRefFrames));
        }

        if (maxVideoBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxVideoBitDepth", maxVideoBitDepth));
        }

        if (requireAvc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireAvc", requireAvc));
        }

        if (deInterlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deInterlace", deInterlace));
        }

        if (requireNonAnamorphic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireNonAnamorphic", requireNonAnamorphic));
        }

        if (transcodingMaxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodingMaxAudioChannels", transcodingMaxAudioChannels));
        }

        if (cpuCoreLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cpuCoreLimit", cpuCoreLimit));
        }

        if (liveStreamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("liveStreamId", liveStreamId));
        }

        if (enableMpegtsM2TsMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMpegtsM2TsMode", enableMpegtsM2TsMode));
        }

        if (videoCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoCodec", videoCodec));
        }

        if (subtitleCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleCodec", subtitleCodec));
        }

        if (transcodeReasons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodeReasons", transcodeReasons));
        }

        if (audioStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioStreamIndex", audioStreamIndex));
        }

        if (videoStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoStreamIndex", videoStreamIndex));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (streamOptions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamOptions", streamOptions));
        }

        if (maxWidth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxWidth", maxWidth));
        }

        if (maxHeight != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxHeight", maxHeight));
        }

        if (enableSubtitlesInManifest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableSubtitlesInManifest", enableSubtitlesInManifest));
        }

        if (enableAudioVbrEncoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAudioVbrEncoding", enableAudioVbrEncoding));
        }

        if (alwaysBurnInSubtitleWhenTranscoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("alwaysBurnInSubtitleWhenTranscoding", alwaysBurnInSubtitleWhenTranscoding));
        }

        final String[] localVarAccepts = {
            "application/x-mpegURL"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "CustomAuthentication" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getLiveHlsStreamValidateBeforeCall(UUID itemId, String container, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Integer maxWidth, Integer maxHeight, Boolean enableSubtitlesInManifest, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'itemId' is set
        if (itemId == null) {
            throw new ApiException("Missing the required parameter 'itemId' when calling getLiveHlsStream(Async)");
        }

        return getLiveHlsStreamCall(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);

    }

    /**
     * Gets a hls live stream.
     * 
     * @param itemId The item id. (required)
     * @param container The audio container. (optional)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param maxWidth Optional. The max width. (optional)
     * @param maxHeight Optional. The max height. (optional)
     * @param enableSubtitlesInManifest Optional. Whether to enable subtitles in the manifest. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Hls live stream retrieved. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public File getLiveHlsStream(UUID itemId, String container, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Integer maxWidth, Integer maxHeight, Boolean enableSubtitlesInManifest, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        ApiResponse<File> localVarResp = getLiveHlsStreamWithHttpInfo(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding);
        return localVarResp.getData();
    }

    /**
     * Gets a hls live stream.
     * 
     * @param itemId The item id. (required)
     * @param container The audio container. (optional)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param maxWidth Optional. The max width. (optional)
     * @param maxHeight Optional. The max height. (optional)
     * @param enableSubtitlesInManifest Optional. Whether to enable subtitles in the manifest. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Hls live stream retrieved. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getLiveHlsStreamWithHttpInfo(UUID itemId, String container, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Integer maxWidth, Integer maxHeight, Boolean enableSubtitlesInManifest, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        okhttp3.Call localVarCall = getLiveHlsStreamValidateBeforeCall(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a hls live stream. (asynchronously)
     * 
     * @param itemId The item id. (required)
     * @param container The audio container. (optional)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param maxWidth Optional. The max width. (optional)
     * @param maxHeight Optional. The max height. (optional)
     * @param enableSubtitlesInManifest Optional. Whether to enable subtitles in the manifest. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Hls live stream retrieved. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLiveHlsStreamAsync(UUID itemId, String container, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Integer maxWidth, Integer maxHeight, Boolean enableSubtitlesInManifest, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getLiveHlsStreamValidateBeforeCall(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMasterHlsAudioPlaylist
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMasterHlsAudioPlaylistCall(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Audio/{itemId}/master.m3u8"
            .replace("{" + "itemId" + "}", localVarApiClient.escapeString(itemId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_static != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("static", _static));
        }

        if (params != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("params", params));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (deviceProfileId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceProfileId", deviceProfileId));
        }

        if (playSessionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("playSessionId", playSessionId));
        }

        if (segmentContainer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentContainer", segmentContainer));
        }

        if (segmentLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentLength", segmentLength));
        }

        if (minSegments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minSegments", minSegments));
        }

        if (mediaSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mediaSourceId", mediaSourceId));
        }

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (audioCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioCodec", audioCodec));
        }

        if (enableAutoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAutoStreamCopy", enableAutoStreamCopy));
        }

        if (allowVideoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowVideoStreamCopy", allowVideoStreamCopy));
        }

        if (allowAudioStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowAudioStreamCopy", allowAudioStreamCopy));
        }

        if (breakOnNonKeyFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakOnNonKeyFrames", breakOnNonKeyFrames));
        }

        if (audioSampleRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioSampleRate", audioSampleRate));
        }

        if (maxAudioBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioBitDepth", maxAudioBitDepth));
        }

        if (maxStreamingBitrate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxStreamingBitrate", maxStreamingBitrate));
        }

        if (audioBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioBitRate", audioBitRate));
        }

        if (audioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioChannels", audioChannels));
        }

        if (maxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioChannels", maxAudioChannels));
        }

        if (profile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("profile", profile));
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (framerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("framerate", framerate));
        }

        if (maxFramerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFramerate", maxFramerate));
        }

        if (copyTimestamps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("copyTimestamps", copyTimestamps));
        }

        if (startTimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTimeTicks", startTimeTicks));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (videoBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoBitRate", videoBitRate));
        }

        if (subtitleStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleStreamIndex", subtitleStreamIndex));
        }

        if (subtitleMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleMethod", subtitleMethod));
        }

        if (maxRefFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRefFrames", maxRefFrames));
        }

        if (maxVideoBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxVideoBitDepth", maxVideoBitDepth));
        }

        if (requireAvc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireAvc", requireAvc));
        }

        if (deInterlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deInterlace", deInterlace));
        }

        if (requireNonAnamorphic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireNonAnamorphic", requireNonAnamorphic));
        }

        if (transcodingMaxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodingMaxAudioChannels", transcodingMaxAudioChannels));
        }

        if (cpuCoreLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cpuCoreLimit", cpuCoreLimit));
        }

        if (liveStreamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("liveStreamId", liveStreamId));
        }

        if (enableMpegtsM2TsMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMpegtsM2TsMode", enableMpegtsM2TsMode));
        }

        if (videoCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoCodec", videoCodec));
        }

        if (subtitleCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleCodec", subtitleCodec));
        }

        if (transcodeReasons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodeReasons", transcodeReasons));
        }

        if (audioStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioStreamIndex", audioStreamIndex));
        }

        if (videoStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoStreamIndex", videoStreamIndex));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (streamOptions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamOptions", streamOptions));
        }

        if (enableAdaptiveBitrateStreaming != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAdaptiveBitrateStreaming", enableAdaptiveBitrateStreaming));
        }

        if (enableAudioVbrEncoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAudioVbrEncoding", enableAudioVbrEncoding));
        }

        final String[] localVarAccepts = {
            "application/x-mpegURL"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "CustomAuthentication" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMasterHlsAudioPlaylistValidateBeforeCall(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'itemId' is set
        if (itemId == null) {
            throw new ApiException("Missing the required parameter 'itemId' when calling getMasterHlsAudioPlaylist(Async)");
        }

        // verify the required parameter 'mediaSourceId' is set
        if (mediaSourceId == null) {
            throw new ApiException("Missing the required parameter 'mediaSourceId' when calling getMasterHlsAudioPlaylist(Async)");
        }

        return getMasterHlsAudioPlaylistCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableAudioVbrEncoding, _callback);

    }

    /**
     * Gets an audio hls playlist stream.
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public File getMasterHlsAudioPlaylist(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding) throws ApiException {
        ApiResponse<File> localVarResp = getMasterHlsAudioPlaylistWithHttpInfo(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableAudioVbrEncoding);
        return localVarResp.getData();
    }

    /**
     * Gets an audio hls playlist stream.
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getMasterHlsAudioPlaylistWithHttpInfo(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding) throws ApiException {
        okhttp3.Call localVarCall = getMasterHlsAudioPlaylistValidateBeforeCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableAudioVbrEncoding, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets an audio hls playlist stream. (asynchronously)
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMasterHlsAudioPlaylistAsync(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMasterHlsAudioPlaylistValidateBeforeCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableAudioVbrEncoding, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMasterHlsVideoPlaylist
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableTrickplay Enable trickplay image playlists being added to master playlist. (optional, default to true)
     * @param enableAudioVbrEncoding Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMasterHlsVideoPlaylistCall(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Videos/{itemId}/master.m3u8"
            .replace("{" + "itemId" + "}", localVarApiClient.escapeString(itemId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_static != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("static", _static));
        }

        if (params != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("params", params));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (deviceProfileId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceProfileId", deviceProfileId));
        }

        if (playSessionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("playSessionId", playSessionId));
        }

        if (segmentContainer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentContainer", segmentContainer));
        }

        if (segmentLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentLength", segmentLength));
        }

        if (minSegments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minSegments", minSegments));
        }

        if (mediaSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mediaSourceId", mediaSourceId));
        }

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (audioCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioCodec", audioCodec));
        }

        if (enableAutoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAutoStreamCopy", enableAutoStreamCopy));
        }

        if (allowVideoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowVideoStreamCopy", allowVideoStreamCopy));
        }

        if (allowAudioStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowAudioStreamCopy", allowAudioStreamCopy));
        }

        if (breakOnNonKeyFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakOnNonKeyFrames", breakOnNonKeyFrames));
        }

        if (audioSampleRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioSampleRate", audioSampleRate));
        }

        if (maxAudioBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioBitDepth", maxAudioBitDepth));
        }

        if (audioBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioBitRate", audioBitRate));
        }

        if (audioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioChannels", audioChannels));
        }

        if (maxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioChannels", maxAudioChannels));
        }

        if (profile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("profile", profile));
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (framerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("framerate", framerate));
        }

        if (maxFramerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFramerate", maxFramerate));
        }

        if (copyTimestamps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("copyTimestamps", copyTimestamps));
        }

        if (startTimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTimeTicks", startTimeTicks));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (maxWidth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxWidth", maxWidth));
        }

        if (maxHeight != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxHeight", maxHeight));
        }

        if (videoBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoBitRate", videoBitRate));
        }

        if (subtitleStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleStreamIndex", subtitleStreamIndex));
        }

        if (subtitleMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleMethod", subtitleMethod));
        }

        if (maxRefFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRefFrames", maxRefFrames));
        }

        if (maxVideoBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxVideoBitDepth", maxVideoBitDepth));
        }

        if (requireAvc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireAvc", requireAvc));
        }

        if (deInterlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deInterlace", deInterlace));
        }

        if (requireNonAnamorphic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireNonAnamorphic", requireNonAnamorphic));
        }

        if (transcodingMaxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodingMaxAudioChannels", transcodingMaxAudioChannels));
        }

        if (cpuCoreLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cpuCoreLimit", cpuCoreLimit));
        }

        if (liveStreamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("liveStreamId", liveStreamId));
        }

        if (enableMpegtsM2TsMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMpegtsM2TsMode", enableMpegtsM2TsMode));
        }

        if (videoCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoCodec", videoCodec));
        }

        if (subtitleCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleCodec", subtitleCodec));
        }

        if (transcodeReasons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodeReasons", transcodeReasons));
        }

        if (audioStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioStreamIndex", audioStreamIndex));
        }

        if (videoStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoStreamIndex", videoStreamIndex));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (streamOptions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamOptions", streamOptions));
        }

        if (enableAdaptiveBitrateStreaming != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAdaptiveBitrateStreaming", enableAdaptiveBitrateStreaming));
        }

        if (enableTrickplay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableTrickplay", enableTrickplay));
        }

        if (enableAudioVbrEncoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAudioVbrEncoding", enableAudioVbrEncoding));
        }

        if (alwaysBurnInSubtitleWhenTranscoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("alwaysBurnInSubtitleWhenTranscoding", alwaysBurnInSubtitleWhenTranscoding));
        }

        final String[] localVarAccepts = {
            "application/x-mpegURL"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "CustomAuthentication" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMasterHlsVideoPlaylistValidateBeforeCall(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'itemId' is set
        if (itemId == null) {
            throw new ApiException("Missing the required parameter 'itemId' when calling getMasterHlsVideoPlaylist(Async)");
        }

        // verify the required parameter 'mediaSourceId' is set
        if (mediaSourceId == null) {
            throw new ApiException("Missing the required parameter 'mediaSourceId' when calling getMasterHlsVideoPlaylist(Async)");
        }

        return getMasterHlsVideoPlaylistCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableTrickplay, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);

    }

    /**
     * Gets a video hls playlist stream.
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableTrickplay Enable trickplay image playlists being added to master playlist. (optional, default to true)
     * @param enableAudioVbrEncoding Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public File getMasterHlsVideoPlaylist(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        ApiResponse<File> localVarResp = getMasterHlsVideoPlaylistWithHttpInfo(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableTrickplay, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding);
        return localVarResp.getData();
    }

    /**
     * Gets a video hls playlist stream.
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableTrickplay Enable trickplay image playlists being added to master playlist. (optional, default to true)
     * @param enableAudioVbrEncoding Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getMasterHlsVideoPlaylistWithHttpInfo(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        okhttp3.Call localVarCall = getMasterHlsVideoPlaylistValidateBeforeCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableTrickplay, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a video hls playlist stream. (asynchronously)
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableTrickplay Enable trickplay image playlists being added to master playlist. (optional, default to true)
     * @param enableAudioVbrEncoding Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMasterHlsVideoPlaylistAsync(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMasterHlsVideoPlaylistValidateBeforeCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableTrickplay, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getVariantHlsAudioPlaylist
     * @param itemId The item id. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVariantHlsAudioPlaylistCall(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Audio/{itemId}/main.m3u8"
            .replace("{" + "itemId" + "}", localVarApiClient.escapeString(itemId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_static != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("static", _static));
        }

        if (params != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("params", params));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (deviceProfileId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceProfileId", deviceProfileId));
        }

        if (playSessionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("playSessionId", playSessionId));
        }

        if (segmentContainer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentContainer", segmentContainer));
        }

        if (segmentLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentLength", segmentLength));
        }

        if (minSegments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minSegments", minSegments));
        }

        if (mediaSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mediaSourceId", mediaSourceId));
        }

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (audioCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioCodec", audioCodec));
        }

        if (enableAutoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAutoStreamCopy", enableAutoStreamCopy));
        }

        if (allowVideoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowVideoStreamCopy", allowVideoStreamCopy));
        }

        if (allowAudioStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowAudioStreamCopy", allowAudioStreamCopy));
        }

        if (breakOnNonKeyFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakOnNonKeyFrames", breakOnNonKeyFrames));
        }

        if (audioSampleRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioSampleRate", audioSampleRate));
        }

        if (maxAudioBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioBitDepth", maxAudioBitDepth));
        }

        if (maxStreamingBitrate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxStreamingBitrate", maxStreamingBitrate));
        }

        if (audioBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioBitRate", audioBitRate));
        }

        if (audioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioChannels", audioChannels));
        }

        if (maxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioChannels", maxAudioChannels));
        }

        if (profile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("profile", profile));
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (framerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("framerate", framerate));
        }

        if (maxFramerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFramerate", maxFramerate));
        }

        if (copyTimestamps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("copyTimestamps", copyTimestamps));
        }

        if (startTimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTimeTicks", startTimeTicks));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (videoBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoBitRate", videoBitRate));
        }

        if (subtitleStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleStreamIndex", subtitleStreamIndex));
        }

        if (subtitleMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleMethod", subtitleMethod));
        }

        if (maxRefFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRefFrames", maxRefFrames));
        }

        if (maxVideoBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxVideoBitDepth", maxVideoBitDepth));
        }

        if (requireAvc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireAvc", requireAvc));
        }

        if (deInterlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deInterlace", deInterlace));
        }

        if (requireNonAnamorphic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireNonAnamorphic", requireNonAnamorphic));
        }

        if (transcodingMaxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodingMaxAudioChannels", transcodingMaxAudioChannels));
        }

        if (cpuCoreLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cpuCoreLimit", cpuCoreLimit));
        }

        if (liveStreamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("liveStreamId", liveStreamId));
        }

        if (enableMpegtsM2TsMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMpegtsM2TsMode", enableMpegtsM2TsMode));
        }

        if (videoCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoCodec", videoCodec));
        }

        if (subtitleCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleCodec", subtitleCodec));
        }

        if (transcodeReasons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodeReasons", transcodeReasons));
        }

        if (audioStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioStreamIndex", audioStreamIndex));
        }

        if (videoStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoStreamIndex", videoStreamIndex));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (streamOptions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamOptions", streamOptions));
        }

        if (enableAudioVbrEncoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAudioVbrEncoding", enableAudioVbrEncoding));
        }

        final String[] localVarAccepts = {
            "application/x-mpegURL"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "CustomAuthentication" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getVariantHlsAudioPlaylistValidateBeforeCall(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'itemId' is set
        if (itemId == null) {
            throw new ApiException("Missing the required parameter 'itemId' when calling getVariantHlsAudioPlaylist(Async)");
        }

        return getVariantHlsAudioPlaylistCall(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, _callback);

    }

    /**
     * Gets an audio stream using HTTP live streaming.
     * 
     * @param itemId The item id. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public File getVariantHlsAudioPlaylist(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding) throws ApiException {
        ApiResponse<File> localVarResp = getVariantHlsAudioPlaylistWithHttpInfo(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding);
        return localVarResp.getData();
    }

    /**
     * Gets an audio stream using HTTP live streaming.
     * 
     * @param itemId The item id. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getVariantHlsAudioPlaylistWithHttpInfo(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding) throws ApiException {
        okhttp3.Call localVarCall = getVariantHlsAudioPlaylistValidateBeforeCall(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets an audio stream using HTTP live streaming. (asynchronously)
     * 
     * @param itemId The item id. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVariantHlsAudioPlaylistAsync(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getVariantHlsAudioPlaylistValidateBeforeCall(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getVariantHlsVideoPlaylist
     * @param itemId The item id. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVariantHlsVideoPlaylistCall(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Videos/{itemId}/main.m3u8"
            .replace("{" + "itemId" + "}", localVarApiClient.escapeString(itemId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_static != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("static", _static));
        }

        if (params != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("params", params));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (deviceProfileId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceProfileId", deviceProfileId));
        }

        if (playSessionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("playSessionId", playSessionId));
        }

        if (segmentContainer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentContainer", segmentContainer));
        }

        if (segmentLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentLength", segmentLength));
        }

        if (minSegments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minSegments", minSegments));
        }

        if (mediaSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mediaSourceId", mediaSourceId));
        }

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (audioCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioCodec", audioCodec));
        }

        if (enableAutoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAutoStreamCopy", enableAutoStreamCopy));
        }

        if (allowVideoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowVideoStreamCopy", allowVideoStreamCopy));
        }

        if (allowAudioStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowAudioStreamCopy", allowAudioStreamCopy));
        }

        if (breakOnNonKeyFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakOnNonKeyFrames", breakOnNonKeyFrames));
        }

        if (audioSampleRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioSampleRate", audioSampleRate));
        }

        if (maxAudioBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioBitDepth", maxAudioBitDepth));
        }

        if (audioBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioBitRate", audioBitRate));
        }

        if (audioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioChannels", audioChannels));
        }

        if (maxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioChannels", maxAudioChannels));
        }

        if (profile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("profile", profile));
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (framerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("framerate", framerate));
        }

        if (maxFramerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFramerate", maxFramerate));
        }

        if (copyTimestamps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("copyTimestamps", copyTimestamps));
        }

        if (startTimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTimeTicks", startTimeTicks));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (maxWidth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxWidth", maxWidth));
        }

        if (maxHeight != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxHeight", maxHeight));
        }

        if (videoBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoBitRate", videoBitRate));
        }

        if (subtitleStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleStreamIndex", subtitleStreamIndex));
        }

        if (subtitleMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleMethod", subtitleMethod));
        }

        if (maxRefFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRefFrames", maxRefFrames));
        }

        if (maxVideoBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxVideoBitDepth", maxVideoBitDepth));
        }

        if (requireAvc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireAvc", requireAvc));
        }

        if (deInterlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deInterlace", deInterlace));
        }

        if (requireNonAnamorphic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireNonAnamorphic", requireNonAnamorphic));
        }

        if (transcodingMaxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodingMaxAudioChannels", transcodingMaxAudioChannels));
        }

        if (cpuCoreLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cpuCoreLimit", cpuCoreLimit));
        }

        if (liveStreamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("liveStreamId", liveStreamId));
        }

        if (enableMpegtsM2TsMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMpegtsM2TsMode", enableMpegtsM2TsMode));
        }

        if (videoCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoCodec", videoCodec));
        }

        if (subtitleCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleCodec", subtitleCodec));
        }

        if (transcodeReasons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodeReasons", transcodeReasons));
        }

        if (audioStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioStreamIndex", audioStreamIndex));
        }

        if (videoStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoStreamIndex", videoStreamIndex));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (streamOptions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamOptions", streamOptions));
        }

        if (enableAudioVbrEncoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAudioVbrEncoding", enableAudioVbrEncoding));
        }

        if (alwaysBurnInSubtitleWhenTranscoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("alwaysBurnInSubtitleWhenTranscoding", alwaysBurnInSubtitleWhenTranscoding));
        }

        final String[] localVarAccepts = {
            "application/x-mpegURL"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "CustomAuthentication" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getVariantHlsVideoPlaylistValidateBeforeCall(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'itemId' is set
        if (itemId == null) {
            throw new ApiException("Missing the required parameter 'itemId' when calling getVariantHlsVideoPlaylist(Async)");
        }

        return getVariantHlsVideoPlaylistCall(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);

    }

    /**
     * Gets a video stream using HTTP live streaming.
     * 
     * @param itemId The item id. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public File getVariantHlsVideoPlaylist(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        ApiResponse<File> localVarResp = getVariantHlsVideoPlaylistWithHttpInfo(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding);
        return localVarResp.getData();
    }

    /**
     * Gets a video stream using HTTP live streaming.
     * 
     * @param itemId The item id. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getVariantHlsVideoPlaylistWithHttpInfo(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        okhttp3.Call localVarCall = getVariantHlsVideoPlaylistValidateBeforeCall(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a video stream using HTTP live streaming. (asynchronously)
     * 
     * @param itemId The item id. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param mediaSourceId The media version id, if playing an alternate version. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVariantHlsVideoPlaylistAsync(UUID itemId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String mediaSourceId, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getVariantHlsVideoPlaylistValidateBeforeCall(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for headMasterHlsAudioPlaylist
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call headMasterHlsAudioPlaylistCall(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Audio/{itemId}/master.m3u8"
            .replace("{" + "itemId" + "}", localVarApiClient.escapeString(itemId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_static != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("static", _static));
        }

        if (params != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("params", params));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (deviceProfileId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceProfileId", deviceProfileId));
        }

        if (playSessionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("playSessionId", playSessionId));
        }

        if (segmentContainer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentContainer", segmentContainer));
        }

        if (segmentLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentLength", segmentLength));
        }

        if (minSegments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minSegments", minSegments));
        }

        if (mediaSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mediaSourceId", mediaSourceId));
        }

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (audioCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioCodec", audioCodec));
        }

        if (enableAutoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAutoStreamCopy", enableAutoStreamCopy));
        }

        if (allowVideoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowVideoStreamCopy", allowVideoStreamCopy));
        }

        if (allowAudioStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowAudioStreamCopy", allowAudioStreamCopy));
        }

        if (breakOnNonKeyFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakOnNonKeyFrames", breakOnNonKeyFrames));
        }

        if (audioSampleRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioSampleRate", audioSampleRate));
        }

        if (maxAudioBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioBitDepth", maxAudioBitDepth));
        }

        if (maxStreamingBitrate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxStreamingBitrate", maxStreamingBitrate));
        }

        if (audioBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioBitRate", audioBitRate));
        }

        if (audioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioChannels", audioChannels));
        }

        if (maxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioChannels", maxAudioChannels));
        }

        if (profile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("profile", profile));
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (framerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("framerate", framerate));
        }

        if (maxFramerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFramerate", maxFramerate));
        }

        if (copyTimestamps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("copyTimestamps", copyTimestamps));
        }

        if (startTimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTimeTicks", startTimeTicks));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (videoBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoBitRate", videoBitRate));
        }

        if (subtitleStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleStreamIndex", subtitleStreamIndex));
        }

        if (subtitleMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleMethod", subtitleMethod));
        }

        if (maxRefFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRefFrames", maxRefFrames));
        }

        if (maxVideoBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxVideoBitDepth", maxVideoBitDepth));
        }

        if (requireAvc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireAvc", requireAvc));
        }

        if (deInterlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deInterlace", deInterlace));
        }

        if (requireNonAnamorphic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireNonAnamorphic", requireNonAnamorphic));
        }

        if (transcodingMaxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodingMaxAudioChannels", transcodingMaxAudioChannels));
        }

        if (cpuCoreLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cpuCoreLimit", cpuCoreLimit));
        }

        if (liveStreamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("liveStreamId", liveStreamId));
        }

        if (enableMpegtsM2TsMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMpegtsM2TsMode", enableMpegtsM2TsMode));
        }

        if (videoCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoCodec", videoCodec));
        }

        if (subtitleCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleCodec", subtitleCodec));
        }

        if (transcodeReasons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodeReasons", transcodeReasons));
        }

        if (audioStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioStreamIndex", audioStreamIndex));
        }

        if (videoStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoStreamIndex", videoStreamIndex));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (streamOptions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamOptions", streamOptions));
        }

        if (enableAdaptiveBitrateStreaming != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAdaptiveBitrateStreaming", enableAdaptiveBitrateStreaming));
        }

        if (enableAudioVbrEncoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAudioVbrEncoding", enableAudioVbrEncoding));
        }

        final String[] localVarAccepts = {
            "application/x-mpegURL"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "CustomAuthentication" };
        return localVarApiClient.buildCall(basePath, localVarPath, "HEAD", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call headMasterHlsAudioPlaylistValidateBeforeCall(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'itemId' is set
        if (itemId == null) {
            throw new ApiException("Missing the required parameter 'itemId' when calling headMasterHlsAudioPlaylist(Async)");
        }

        // verify the required parameter 'mediaSourceId' is set
        if (mediaSourceId == null) {
            throw new ApiException("Missing the required parameter 'mediaSourceId' when calling headMasterHlsAudioPlaylist(Async)");
        }

        return headMasterHlsAudioPlaylistCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableAudioVbrEncoding, _callback);

    }

    /**
     * Gets an audio hls playlist stream.
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public File headMasterHlsAudioPlaylist(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding) throws ApiException {
        ApiResponse<File> localVarResp = headMasterHlsAudioPlaylistWithHttpInfo(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableAudioVbrEncoding);
        return localVarResp.getData();
    }

    /**
     * Gets an audio hls playlist stream.
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> headMasterHlsAudioPlaylistWithHttpInfo(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding) throws ApiException {
        okhttp3.Call localVarCall = headMasterHlsAudioPlaylistValidateBeforeCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableAudioVbrEncoding, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets an audio hls playlist stream. (asynchronously)
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param maxStreamingBitrate Optional. The maximum streaming bitrate. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableAudioVbrEncoding Optional. Whether to enable Audio Encoding. (optional, default to true)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Audio stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call headMasterHlsAudioPlaylistAsync(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer maxStreamingBitrate, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableAudioVbrEncoding, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = headMasterHlsAudioPlaylistValidateBeforeCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableAudioVbrEncoding, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for headMasterHlsVideoPlaylist
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableTrickplay Enable trickplay image playlists being added to master playlist. (optional, default to true)
     * @param enableAudioVbrEncoding Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call headMasterHlsVideoPlaylistCall(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Videos/{itemId}/master.m3u8"
            .replace("{" + "itemId" + "}", localVarApiClient.escapeString(itemId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_static != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("static", _static));
        }

        if (params != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("params", params));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (deviceProfileId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceProfileId", deviceProfileId));
        }

        if (playSessionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("playSessionId", playSessionId));
        }

        if (segmentContainer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentContainer", segmentContainer));
        }

        if (segmentLength != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segmentLength", segmentLength));
        }

        if (minSegments != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minSegments", minSegments));
        }

        if (mediaSourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mediaSourceId", mediaSourceId));
        }

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deviceId", deviceId));
        }

        if (audioCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioCodec", audioCodec));
        }

        if (enableAutoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAutoStreamCopy", enableAutoStreamCopy));
        }

        if (allowVideoStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowVideoStreamCopy", allowVideoStreamCopy));
        }

        if (allowAudioStreamCopy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("allowAudioStreamCopy", allowAudioStreamCopy));
        }

        if (breakOnNonKeyFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("breakOnNonKeyFrames", breakOnNonKeyFrames));
        }

        if (audioSampleRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioSampleRate", audioSampleRate));
        }

        if (maxAudioBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioBitDepth", maxAudioBitDepth));
        }

        if (audioBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioBitRate", audioBitRate));
        }

        if (audioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioChannels", audioChannels));
        }

        if (maxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxAudioChannels", maxAudioChannels));
        }

        if (profile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("profile", profile));
        }

        if (level != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("level", level));
        }

        if (framerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("framerate", framerate));
        }

        if (maxFramerate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxFramerate", maxFramerate));
        }

        if (copyTimestamps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("copyTimestamps", copyTimestamps));
        }

        if (startTimeTicks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTimeTicks", startTimeTicks));
        }

        if (width != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("width", width));
        }

        if (height != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("height", height));
        }

        if (maxWidth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxWidth", maxWidth));
        }

        if (maxHeight != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxHeight", maxHeight));
        }

        if (videoBitRate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoBitRate", videoBitRate));
        }

        if (subtitleStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleStreamIndex", subtitleStreamIndex));
        }

        if (subtitleMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleMethod", subtitleMethod));
        }

        if (maxRefFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxRefFrames", maxRefFrames));
        }

        if (maxVideoBitDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxVideoBitDepth", maxVideoBitDepth));
        }

        if (requireAvc != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireAvc", requireAvc));
        }

        if (deInterlace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deInterlace", deInterlace));
        }

        if (requireNonAnamorphic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("requireNonAnamorphic", requireNonAnamorphic));
        }

        if (transcodingMaxAudioChannels != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodingMaxAudioChannels", transcodingMaxAudioChannels));
        }

        if (cpuCoreLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cpuCoreLimit", cpuCoreLimit));
        }

        if (liveStreamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("liveStreamId", liveStreamId));
        }

        if (enableMpegtsM2TsMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableMpegtsM2TsMode", enableMpegtsM2TsMode));
        }

        if (videoCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoCodec", videoCodec));
        }

        if (subtitleCodec != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subtitleCodec", subtitleCodec));
        }

        if (transcodeReasons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transcodeReasons", transcodeReasons));
        }

        if (audioStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("audioStreamIndex", audioStreamIndex));
        }

        if (videoStreamIndex != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("videoStreamIndex", videoStreamIndex));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (streamOptions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamOptions", streamOptions));
        }

        if (enableAdaptiveBitrateStreaming != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAdaptiveBitrateStreaming", enableAdaptiveBitrateStreaming));
        }

        if (enableTrickplay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableTrickplay", enableTrickplay));
        }

        if (enableAudioVbrEncoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enableAudioVbrEncoding", enableAudioVbrEncoding));
        }

        if (alwaysBurnInSubtitleWhenTranscoding != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("alwaysBurnInSubtitleWhenTranscoding", alwaysBurnInSubtitleWhenTranscoding));
        }

        final String[] localVarAccepts = {
            "application/x-mpegURL"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "CustomAuthentication" };
        return localVarApiClient.buildCall(basePath, localVarPath, "HEAD", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call headMasterHlsVideoPlaylistValidateBeforeCall(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'itemId' is set
        if (itemId == null) {
            throw new ApiException("Missing the required parameter 'itemId' when calling headMasterHlsVideoPlaylist(Async)");
        }

        // verify the required parameter 'mediaSourceId' is set
        if (mediaSourceId == null) {
            throw new ApiException("Missing the required parameter 'mediaSourceId' when calling headMasterHlsVideoPlaylist(Async)");
        }

        return headMasterHlsVideoPlaylistCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableTrickplay, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);

    }

    /**
     * Gets a video hls playlist stream.
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableTrickplay Enable trickplay image playlists being added to master playlist. (optional, default to true)
     * @param enableAudioVbrEncoding Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public File headMasterHlsVideoPlaylist(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        ApiResponse<File> localVarResp = headMasterHlsVideoPlaylistWithHttpInfo(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableTrickplay, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding);
        return localVarResp.getData();
    }

    /**
     * Gets a video hls playlist stream.
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableTrickplay Enable trickplay image playlists being added to master playlist. (optional, default to true)
     * @param enableAudioVbrEncoding Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> headMasterHlsVideoPlaylistWithHttpInfo(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding) throws ApiException {
        okhttp3.Call localVarCall = headMasterHlsVideoPlaylistValidateBeforeCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableTrickplay, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a video hls playlist stream. (asynchronously)
     * 
     * @param itemId The item id. (required)
     * @param mediaSourceId The media version id, if playing an alternate version. (required)
     * @param _static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. (optional)
     * @param params The streaming parameters. (optional)
     * @param tag The tag. (optional)
     * @param deviceProfileId Optional. The dlna device profile id to utilize. (optional)
     * @param playSessionId The play session id. (optional)
     * @param segmentContainer The segment container. (optional)
     * @param segmentLength The segment length. (optional)
     * @param minSegments The minimum number of segments. (optional)
     * @param deviceId The device id of the client requesting. Used to stop encoding processes when needed. (optional)
     * @param audioCodec Optional. Specify an audio codec to encode to, e.g. mp3. (optional)
     * @param enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. (optional)
     * @param allowVideoStreamCopy Whether or not to allow copying of the video stream url. (optional)
     * @param allowAudioStreamCopy Whether or not to allow copying of the audio stream url. (optional)
     * @param breakOnNonKeyFrames Optional. Whether to break on non key frames. (optional)
     * @param audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100. (optional)
     * @param maxAudioBitDepth Optional. The maximum audio bit depth. (optional)
     * @param audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. (optional)
     * @param audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2. (optional)
     * @param maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2. (optional)
     * @param profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. (optional)
     * @param level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. (optional)
     * @param framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. (optional)
     * @param copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false. (optional)
     * @param startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms. (optional)
     * @param width Optional. The fixed horizontal resolution of the encoded video. (optional)
     * @param height Optional. The fixed vertical resolution of the encoded video. (optional)
     * @param maxWidth Optional. The maximum horizontal resolution of the encoded video. (optional)
     * @param maxHeight Optional. The maximum vertical resolution of the encoded video. (optional)
     * @param videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. (optional)
     * @param subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. (optional)
     * @param subtitleMethod Optional. Specify the subtitle delivery method. (optional)
     * @param maxRefFrames Optional. (optional)
     * @param maxVideoBitDepth Optional. The maximum video bit depth. (optional)
     * @param requireAvc Optional. Whether to require avc. (optional)
     * @param deInterlace Optional. Whether to deinterlace the video. (optional)
     * @param requireNonAnamorphic Optional. Whether to require a non anamorphic stream. (optional)
     * @param transcodingMaxAudioChannels Optional. The maximum number of audio channels to transcode. (optional)
     * @param cpuCoreLimit Optional. The limit of how many cpu cores to use. (optional)
     * @param liveStreamId The live stream id. (optional)
     * @param enableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode. (optional)
     * @param videoCodec Optional. Specify a video codec to encode to, e.g. h264. (optional)
     * @param subtitleCodec Optional. Specify a subtitle codec to encode to. (optional)
     * @param transcodeReasons Optional. The transcoding reason. (optional)
     * @param audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used. (optional)
     * @param videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used. (optional)
     * @param context Optional. The MediaBrowser.Model.Dlna.EncodingContext. (optional)
     * @param streamOptions Optional. The streaming options. (optional)
     * @param enableAdaptiveBitrateStreaming Enable adaptive bitrate streaming. (optional, default to true)
     * @param enableTrickplay Enable trickplay image playlists being added to master playlist. (optional, default to true)
     * @param enableAudioVbrEncoding Whether to enable Audio Encoding. (optional, default to true)
     * @param alwaysBurnInSubtitleWhenTranscoding Whether to always burn in subtitles when transcoding. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Video stream returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call headMasterHlsVideoPlaylistAsync(UUID itemId, String mediaSourceId, Boolean _static, String params, String tag, String deviceProfileId, String playSessionId, String segmentContainer, Integer segmentLength, Integer minSegments, String deviceId, String audioCodec, Boolean enableAutoStreamCopy, Boolean allowVideoStreamCopy, Boolean allowAudioStreamCopy, Boolean breakOnNonKeyFrames, Integer audioSampleRate, Integer maxAudioBitDepth, Integer audioBitRate, Integer audioChannels, Integer maxAudioChannels, String profile, String level, Float framerate, Float maxFramerate, Boolean copyTimestamps, Long startTimeTicks, Integer width, Integer height, Integer maxWidth, Integer maxHeight, Integer videoBitRate, Integer subtitleStreamIndex, SubtitleDeliveryMethod subtitleMethod, Integer maxRefFrames, Integer maxVideoBitDepth, Boolean requireAvc, Boolean deInterlace, Boolean requireNonAnamorphic, Integer transcodingMaxAudioChannels, Integer cpuCoreLimit, String liveStreamId, Boolean enableMpegtsM2TsMode, String videoCodec, String subtitleCodec, String transcodeReasons, Integer audioStreamIndex, Integer videoStreamIndex, EncodingContext context, Map<String, String> streamOptions, Boolean enableAdaptiveBitrateStreaming, Boolean enableTrickplay, Boolean enableAudioVbrEncoding, Boolean alwaysBurnInSubtitleWhenTranscoding, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = headMasterHlsVideoPlaylistValidateBeforeCall(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, maxWidth, maxHeight, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodeReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, enableTrickplay, enableAudioVbrEncoding, alwaysBurnInSubtitleWhenTranscoding, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
