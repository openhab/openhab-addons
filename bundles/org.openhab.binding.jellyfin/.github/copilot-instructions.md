
# GitHub Copilot Instructions for openHAB Development

These instructions are designed to guide the GitHub Copilot AI in assisting with code generation and modifications for the openHAB project. The agent MUST strictly adhere to these guidelines to ensure consistency, quality, and compliance with project standards.

## Planning Phase Clarification


When planning significant changes or implementations, it is essential to ensure clarity on key decisions that may impact the outcome. To facilitate this, the agent MUST adhere to the following guidelines:

- **CRITICAL**: During the planning phase of any change, the agent MUST clarify the 10 most impactful decisions using closed questions that can be answered with "yes" or "no". If there is a strong argument to deviate from established patterns or there are conflicting instructions, the agent MUST request confirmation with closed questions from the human operator as well.

Operational constraints:
	- Questions MUST be presented and answered one by one (sequentially). Do NOT batch questions.
	- Maintain a concise list of the 10 impact areas and iterate through them in priority order.
	- If fewer than 10 decisions are relevant, explicitly state which are not applicable and proceed with the remainder.
	- Block further implementation steps until each question has received an explicit "yes" or "no" answer.

## Code Generation Guidelines



## Copyright and License Headers

- **CRITICAL**: Every created file MUST contain the project's copyright and license header at the top, matching the format and content used in existing source files (see NOTICE or other Java files for reference).


## Author Tag for New Classes

- **CRITICAL**: Every new class MUST include an `@author` tag in the class-level Javadoc (not in the file header), stating "<git user name> - Initial contribution". Do not reference these instructions in the author tag. Replace `<git user name>` by the value of `git config user.name` (without eMail or angle brackets).

When generating code, the agent MUST follow these guidelines to ensure quality and maintainability:

- **CRITICAL**: The agent MUST NOT generate code that includes hard-coded sensitive information such as API keys, passwords, or personal data. Instead, it should use environment variables or secure vaults to manage such information.
- **CRITICAL**: The definitions available from the openHAB [guildelines]<https://www.openhab.org/docs/developer/guidelines.html> must be followed.
- **CRITICAL**: Strictly follow the SOLID principles. Especially separate concerns, this also applies to private methods.
- **CRITICAL**: Adhere to the existing architectural patterns and coding conventions used in the openHAB project.
- **CRITICAL**: Follow the [build system]<https://www.openhab.org/docs/developer/buildsystem.html> guidelines for dependency management and project structure.
- **CRITICAL**: Ensure compatibility with the Java versions supported by openHAB.
- **CRITICAL**: Leverage Java 21 language features where appropriate to imrpove code clarity and performance.
- **CRITICAL**: Leverate existing utility classes and methods within the openHAB codebase to maintain consistency and reduce redundancy.
- **CRITICAL**: All code that is part of the package `org.openhab.binding.jellyfin.internal.api.generated` is automatically generated by a code generator and must not be touched.
- Ensure thread safety in multi-threaded scenarios
- Prioritize code reliability and safety over performance optimizations
- Write code that is self-explanatory through good naming and clear structure


### Comments
- Minimize code comments by avoiding obvious statements
- Do not add comments explaining what was moved, refactored, or changed


### Logging
- Never add logging without specific instructions to do so.
- Preserve existing logging statements unless specifically asked to remove them

## Code Quality Gates


### Compile

- **CRITICAL**: Only use maven (`mvn`). Never use Visual Studio Code tasks or scripts to build the code.
- Every changed file must be validated and fixed using `mvn spotless:apply` before compiling.
- The added or changed code must compile without warnings


### Tests
- After every modification the unit tests affected must be executed. If new logic was added, new test must be added. All unit tests must pass. There might be integration tests that can fail. Ask, if it is unclear if a failing test is an integration test.


### Code Style
- Added or changed code must report not code style warnings from static code analysis.



## Additional Guidance: Robust Handler Test Creation

When writing or maintaining unit tests for handler logic (e.g., server URI resolution), follow these best practices to ensure reliability and maintainability:

### Mocking and Field Injection
	- When testing handler logic that accesses the `thing` field (from `BaseThingHandler`), ensure the test subclass sets the base class's `thing` field to the test's mock. Use reflection if necessary.
	- Do not rely solely on overriding `getThing()`; the actual field must be set for internal logic to work as expected.

### Configuration Injection
	- If the handler constructor or logic uses `getConfigAs`, ensure the test subclass provides the correct configuration instance or mock at construction time.
	- Use a static helper or similar pattern to inject the configuration mock for both the constructor and subsequent calls.

### Exception Handling in Reflection
	- When invoking private methods via reflection (e.g., `resolveServerUri()`), always unwrap `InvocationTargetException` to assert on the real cause.
	- Write assertions that accept all possible exception types thrown by the production code (e.g., `IllegalArgumentException`, `URISyntaxException`, `IllegalStateException`).

### Test Coverage
	- Cover all logic branches: valid Thing property, invalid Thing property, unsupported scheme, fallback to configuration, and configuration errors.
	- Always set up the mock Thing and Configuration for each test scenario.

### No Production Code Changes for Testability
	- Do not modify production code solely for testability. Use subclassing, reflection, and proper mock setup in tests.

### Formatting and Style
	- Run `mvn spotless:apply` after any test changes to ensure code style compliance.

#### Example Patterns

	Setting the `thing` field in a test subclass:

	```java
	try {
		Field thingField = BaseThingHandler.class.getDeclaredField("thing");
		thingField.setAccessible(true);
		thingField.set(this, mockThing);
	} catch (Exception e) {
		throw new RuntimeException(e);
	}
	```

	Unwrapping exceptions in assertions:

	```java
	Exception ex = assertThrows(Exception.class, () -> {
		try {
			method.invoke(handler);
		} catch (InvocationTargetException ite) {
			throw ite.getCause();
		}
	});
	assertTrue(ex instanceof IllegalArgumentException || ...);
	```

Follow these patterns and lessons to ensure robust, reliable, and maintainable unit tests for handler logic in the openHAB Jellyfin binding. This will help future agents and developers avoid common pitfalls and ensure test correctness.

- Update relevant documentation to reflect code changes.

### Markdown

- Markdown documents must not contain linter warnings. Always resolve all markdown linter issues before considering documentation complete.
- max-one-sentence-per-line: Max 1 sentence should be on a line (markdownlint max-one-sentence-per-line).
- MD012/no-multiple-blanks: Multiple consecutive blank lines are not allowed.


Entry point for documentation changes is the `docs` folder in the repository root.




### Documentation Structure and Patterns

- The main documentation page (e.g., `architecture.md`) must provide a high-level overview, a clear table of contents, and short summaries of each major architectural area.
- The main Mermaid architecture diagram **MUST NOT** include members of records (record fields or methods) for clarity and overview. Instead, add a dedicated section (e.g., "Record Details") to document all record members and their structure.
- For complex or detailed topics (such as handler architecture, utility classes, task management, error handling, discovery, or API structure), create dedicated pages in a subfolder (e.g., `docs/architecture/`).
- **CRITICAL**: Each documentation detail page must follow the SOLID principle—one responsibility per page. If a detail page covers more than one architectural concern, split it into separate pages (e.g., do not mix discovery and API architecture on a single page).
- Each dedicated page must include:
	- A clear heading and summary of its focus area.
	- The relevant Mermaid diagram(s), validated for the current Mermaid version.
	- A summary section and, if needed, links back to the main overview.
	- If records are used, only visualize their usage (e.g., as return types or associations) without showing their members. Do not include record members in these diagrams; details must be in the dedicated Record Details section only.
- The main documentation page must include:
	- A table of contents with links to all dedicated detail pages.
	- Short summaries of each area, referencing the detail pages.
	- A dedicated section listing all record details (members and structure) referenced in the architecture, with a dedicated Mermaid diagram for records.
- Do not include development or contribution guidelines in the documentation section—only document the existing implementation and its structure.

#### Table of Contents (TOC)
- Any changes to headings, section structure, or content organization MUST include updating the table of contents.
- Use the same format and indentation level as the existing TOC.
- Ensure no orphaned TOC entries remain after content changes.
- Check that TOC structure matches document hierarchy.
- All TOC links must match the actual heading anchors (lowercase, hyphens for spaces, special characters removed).

#### Sections
- When adding new sections, add corresponding TOC entries at the appropriate hierarchy level.
- When removing sections, remove corresponding TOC entries.
- Maintain logical section ordering in both the TOC and document structure.

#### Diagrams
- Use <https://docs.mermaidchart.com/mermaid-oss/intro/index.html> for diagrams and visualizations.
- **CRITICAL**: Diagrams MUST focus on the architecture and high-level workflows. Avoid low-level implementation details.
- Validate all Mermaid diagrams for syntax and rendering with the current Mermaid version before adding or updating.
- Leverage enhanced features like subgraphs, styling, and notes to improve clarity.
- Place diagrams in dedicated detail pages if they are complex or focused on a specific subsystem.
- Ensure diagrams are well-integrated into the documentation with appropriate captions, summaries, and references from the main overview.


## Source Code Management

- Follow the established branching strategy of the openHAB project.
- Commit messages MUST be clear, concise, and follow the conventional commit format.
- **CRITICAL**: Agent MUST not automatically commit changes. All changes MUST be reviewed and approved by a human developer before being committed to the repository.
- **CRITICAL**: Never add the "Close (issue-number)" statement to commit messages. This must be done by a human developer during the PR creation.