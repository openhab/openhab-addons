
# GitHub Copilot Instructions for openHAB Development

These instructions are designed to guide the GitHub Copilot AI in assisting
with code generation and modifications for the openHAB project. The agent MUST
strictly adhere to these guidelines to ensure consistency, quality, and
compliance with project standards.

## Planning Phase Clarification

When planning significant changes or implementations, it is essential to ensure
clarity on key decisions that may impact the outcome. To facilitate this, the
agent MUST adhere to the following guidelines:

- **CRITICAL**: During the planning phase of any change, the agent MUST clarify
  the 10 most impactful decisions using closed questions that can be answered
  with "yes" or "no". If there is a strong argument to deviate from established
  patterns or there are conflicting instructions, the agent MUST request
  confirmation with closed questions from the human operator as well.

Operational constraints:

- Questions MUST be presented and answered one by one (sequentially). Do NOT
  batch questions.
  priority order.
- If fewer than 10 decisions are relevant, explicitly state which are not
- Block further implementation steps until each question has received an

## Copyright and License Headers

## Author Tag for New Classes
<!-- markdownlint-disable-next-line MD033 -->
- **CRITICAL**: Every new class MUST include an `@author` tag in the
  class-level Javadoc (not in the file header), stating "\<git user name\> - Initial
  contribution". Do not reference these instructions in the author tag. Replace
  `\<git user name\>` by the value of `git config user.name` (without eMail or angle
  brackets).
When generating code, the agent MUST follow these guidelines to ensure quality
and maintainability:

  it should use environment variables or secure vaults to manage such
  - **CRITICAL**: The definitions available from the openHAB
    followed.
    concerns, this also applies to private methods.
    conventions used in the openHAB project.
  [build system]<https://www.openhab.org/docs/developer/buildsystem.html>
  guidelines for dependency management and project structure.
- **CRITICAL**: Ensure compatibility with the Java versions supported by
  openHAB.
  code clarity and performance.
- **CRITICAL**: Leverate existing utility classes and methods within the openHAB
  codebase to maintain consistency and reduce redundancy.
- **CRITICAL**: All code that is part of the package
  `org.openhab.binding.jellyfin.internal.api.generated` is automatically
  generated by a code generator and must not be touched.
- Ensure thread safety in multi-threaded scenarios
  ```java

- Prioritize code reliability and safety over performance optimizations
- Write code that is self-explanatory through good naming and clear structure

### Comments

- Minimize code comments by avoiding obvious statements
- Do not add comments explaining what was moved, refactored, or changed

### Logging

- Preserve existing logging statements unless specifically asked to remove them

## Code Quality Gates

- **CRITICAL**: Only use maven (`mvn`). Never use Visual Studio Code tasks or
- Every changed file must be validated and fixed using `mvn spotless:apply`
  before compiling.
- The added or changed code must compile without warnings

- After every modification the unit tests affected must be executed. If new
  might be integration tests that can fail. Ask, if it is unclear if a failing

- Added or changed code must report not code style warnings from static code
  analysis.

## Additional Guidance: Robust Handler Test Creation

When writing or maintaining unit tests for handler logic (e.g., server URI
resolution), follow these best practices to ensure reliability and
maintainability:

### Mocking and Field Injection

- When testing handler logic that accesses the `thing` field (from
  `BaseThingHandler`), ensure the test subclass sets the base class's `thing`
  field to the test's mock. Use reflection if necessary.
- Do not rely solely on overriding `getThing()`; the actual field must be set
  for internal logic to work as expected.

### Configuration Injection

- If the handler constructor or logic uses `getConfigAs`, ensure the test
  subclass provides the correct configuration instance or mock at construction
  time.
- Use a static helper or similar pattern to inject the configuration mock for
  both the constructor and subsequent calls.

### Exception Handling in Reflection

- When invoking private methods via reflection (e.g., `resolveServerUri()`),
  always unwrap `InvocationTargetException` to assert on the real cause.
- Write assertions that accept all possible exception types thrown by the
  production code (e.g., `IllegalArgumentException`, `URISyntaxException`,
  `IllegalStateException`).

### Test Coverage

- Cover all logic branches: valid Thing property, invalid Thing property,
  unsupported scheme, fallback to configuration, and configuration errors.
- Always set up the mock Thing and Configuration for each test scenario.

### No Production Code Changes for Testability

- Do not modify production code solely for testability. Use subclassing,
  reflection, and proper mock setup in tests.

#### Example Patterns

Setting the `thing` field in a test subclass:

```java
try {
  Field thingField = BaseThingHandler.class.getDeclaredField("thing");
  thingField.setAccessible(true);
  thingField.set(this, mockThing);
} catch (Exception e) {
 throw new RuntimeException(e);
}

```

## Markdown Quality and Compliance Requirements

**CRITICAL:** All new or changed documentation content (including
`.github/copilot-instructions.md` and all files in `docs/`) MUST be fully
compliant with the markdownlint rules and the `.editorconfig` settings for
markdown files before being considered complete.

- Always run a markdown linter (e.g., `markdownlint`) on all documentation files
  before submitting or merging changes. All reported issues (including line
  length, multiple blank lines, code block language, and sentence-per-line
  rules) MUST be fixed.
- The `.editorconfig` file in the repository root enforces markdown style rules
  (indentation, max line length, etc.) for all `*.md` files. Your editor MUST
  respect these settings when editing documentation.
- Never remove or lose information when fixing linter issues. If a linter
  warning is caused by formatting, reformat the content (e.g., convert stray
  lines or fragments into proper bullet lists or paragraphs) rather than
  deleting it.
- When restoring or reformatting content, ensure all original information and
  intent is preserved, especially for workflow explanations and step lists.
- When fixing documentation, always check for accidental loss of context or
  meaning, especially after automated formatting or linter fixes.
- If a linter or formatter removes or alters content, review the diff and
  restore any lost information in a markdownlint-compliant way.
- When in doubt, prefer clarity and completeness over strict formatting, but
  always resolve linter errors in a way that preserves all technical and
  instructional content.

**First step for fixing markdown violations:**
Always attempt to auto-fix markdown issues using `markdownlint --fix` before
making manual changes.
This can resolve many common formatting problems
automatically.
Entry point for documentation changes is the `docs` folder in the repository
root.

### Documentation Structure and Patterns

- The main documentation page (e.g., `architecture.md`) must provide a
  high-level overview, a clear table of contents, and short summaries of each
  major architectural area.
- The main Mermaid architecture diagram **MUST NOT** include members of records
  (record fields or methods) for clarity and overview. Instead, add a dedicated
  section (e.g., "Record Details") to document all record members and their
  structure.
- For complex or detailed topics (such as handler architecture, utility classes,
  task management, error handling, discovery, or API structure), create
  dedicated pages in a subfolder (e.g., `docs/architecture/`).
- **CRITICAL**: Each documentation detail page must follow the SOLID principle—one
  responsibility per page. If a detail page covers more than one architectural
  concern, split it into separate pages (e.g., do not mix discovery and API
  architecture on a single page).
  - Each dedicated page must include:
    - A clear heading and summary of its focus area.
    - The relevant Mermaid diagram(s), validated for the current Mermaid version.
    - A summary section and, if needed, links back to the main overview.
    - If records are used, only visualize their usage (e.g., as return types or
      associations) without showing their members. Do not include record members
      in these diagrams; details must be in the dedicated Record Details
      section only.
    - Validate all Mermaid diagrams after any change to ensure they render and
      are syntactically correct.
  - The main documentation page must include:
    - A table of contents with links to all dedicated detail pages.
    - Short summaries of each area, referencing the detail pages.

    - A dedicated section listing all record details (members and structure)
      referenced in the architecture, with a dedicated Mermaid diagram for records.
  - Do not include development or contribution guidelines in the documentation
    section—only document the existing implementation and its structure.

  - Do not include development or contribution guidelines in the documentation
    section—only document the existing implementation and its structure.

#### Table of Contents (TOC)

- Any changes to headings, section structure, or content organization MUST
  include updating the table of contents.
- Use the same format and indentation level as the existing TOC.
- Ensure no orphaned TOC entries remain after content changes.
- Check that TOC structure matches document hierarchy.
- All TOC links must match the actual heading anchors (lowercase, hyphens for
  spaces, special characters removed).

#### Sections

- When adding new sections, add corresponding TOC entries at the appropriate
  hierarchy level.
- When removing sections, remove corresponding TOC entries.
- Maintain logical section ordering in both the TOC and document structure.

#### Diagrams

- Use <https://docs.mermaidchart.com/mermaid-oss/intro/index.html> for diagrams
  and visualizations.
- **CRITICAL**: Diagrams MUST focus on the architecture and high-level
  workflows. Avoid low-level implementation details.
- Validate all Mermaid diagrams for syntax and rendering with the current
  Mermaid version before adding or updating.
- Leverage enhanced features like subgraphs, styling, and notes to improve
  clarity.
- Place diagrams in dedicated detail pages if they are complex or focused on a
  specific subsystem.
- Ensure diagrams are well-integrated into the documentation with appropriate
  captions, summaries, and references from the main overview.

## Source Code Management

- Follow the established branching strategy of the openHAB project.
- Commit messages MUST be clear, concise, and follow the conventional commit
  format.
- **CRITICAL**: Agent MUST not automatically commit changes. All changes MUST be
  reviewed and approved by a human developer before being committed to the
  repository.
- **CRITICAL**: Never add the "Close (issue-number)" statement to commit

  messages. This must be done by a human developer during the PR creation.
