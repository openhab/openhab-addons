/*
 * Copyright (c) 2010-2025 Contributors to the openHAB project
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.openhab.automation.java223.internal.codegeneration;

import java.io.IOException;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.eclipse.jdt.annotation.NonNullByDefault;
import org.eclipse.jdt.annotation.Nullable;
import org.openhab.core.automation.annotation.RuleAction;
import org.openhab.core.automation.type.ActionType;
import org.openhab.core.automation.type.ModuleTypeRegistry;
import org.openhab.core.automation.type.Output;
import org.openhab.core.common.ThreadPoolManager;
import org.openhab.core.items.Item;
import org.openhab.core.items.ItemRegistry;
import org.openhab.core.thing.Thing;
import org.openhab.core.thing.ThingRegistry;
import org.openhab.core.thing.binding.ThingActions;
import org.openhab.core.thing.binding.ThingActionsScope;
import org.osgi.framework.BundleContext;
import org.osgi.framework.InvalidSyntaxException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import freemarker.template.TemplateExceptionHandler;
import freemarker.template.TemplateMethodModelEx;

/**
 * The SourceGenerator is responsible for generating the additional classes
 * helping for rule development. It uses freemarker as a template engine.
 * Include a delayed (debounced) mechanism to prevent creating a file multiple times when there are many
 * modifications in the registry (especially useful at startup)
 *
 * @author Gwendal Roulleau - Initial contribution
 */
@NonNullByDefault
public class SourceGenerator {

    public static final String GENERATED = "generated";
    public static final String AUTOGENERATED_WARNING = "/** JAVA223 AUTOGENERATED CODE - DO NOT EDIT */";

    private final Logger logger = LoggerFactory.getLogger(SourceGenerator.class);

    private final ItemRegistry itemRegistry;
    private final ThingRegistry thingRegistry;
    private final ModuleTypeRegistry moduleTypeRegistry;
    private final BundleContext bundleContext;

    private final SourceWriter sourceWriter;
    private final DependencyGenerator dependencyGenerator;
    private final InjectedCodeGenerator injectedCodeGenerator;

    private static final String TPL_LOCATION = "/generated/";

    Configuration cfg = new Configuration(Configuration.VERSION_2_3_32);

    // keep a reference to the generation method to use as a key in the delayed/debounced map
    private final InternalGenerator actionGeneration = new InternalGenerator(this::internalGenerateActions, "Actions");
    private final InternalGenerator itemGeneration = new InternalGenerator(this::internalGenerateItems, "Items");
    private final InternalGenerator thingGeneration = new InternalGenerator(this::internalGenerateThings, "Things");
    private final Map<InternalGenerator, ScheduledFuture<?>> futureGeneration = new HashMap<>();

    private final ScheduledExecutorService scheduledPool = ThreadPoolManager
            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);

    /**
     * @param sourceWriter The real writer, to avoid writing something already existing
     * @param dependencyGenerator We will add to the dependency generator a list of package we think would be
     *            interesting to export
     * @param injectedCodeGenerator A code generator for import statement and default injected field declaration
     * @param itemRegistry Lookup inside the itemRegistry to generate a list of item
     * @param thingRegistry Lookup inside the thingRegistry to generate a list of thing
     * @param bundleContext We will search for class action inside
     */
    public SourceGenerator(SourceWriter sourceWriter, DependencyGenerator dependencyGenerator,
            InjectedCodeGenerator injectedCodeGenerator, ItemRegistry itemRegistry, ThingRegistry thingRegistry,
            ModuleTypeRegistry moduleTypeRegistry, BundleContext bundleContext) {
        this.sourceWriter = sourceWriter;
        this.itemRegistry = itemRegistry;
        this.thingRegistry = thingRegistry;
        this.moduleTypeRegistry = moduleTypeRegistry;
        this.bundleContext = bundleContext;
        this.dependencyGenerator = dependencyGenerator;
        this.injectedCodeGenerator = injectedCodeGenerator;

        cfg.setClassForTemplateLoading(SourceGenerator.class, "/");
        cfg.setDefaultEncoding("UTF-8");
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
    }

    private static void deleteDirIfEmpty(Path directory) throws IOException {
        if (Files.isDirectory(directory)) {
            try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(directory)) {
                if (!dirStream.iterator().hasNext()) {
                    Files.delete(directory);
                }
            }
        }
    }

    private static boolean isAJavaGeneratedFile(Path path) throws IOException {
        if (Files.exists(path) && Files.isRegularFile(path) && path.getFileName().toString().endsWith(".java")) {
            try (Stream<String> lines = Files.lines(path)) {
                return AUTOGENERATED_WARNING.equals(lines.findFirst().orElse(null));
            }
        }
        return false;
    }

    /**
     * Delaying generation is especially useful during startup, when item and thing are not all properly initialized.
     * To avoid overwriting a file with an incomplete list of things/items/actions, we must avoid writing to the file if
     * the registries are not completely ready.
     * Until there is no more item/thing/action activating, this code will delay code generation.
     *
     * @param generator The generator responsible for creating the class
     * @param writeGuardTime Delay before writing the file. Each call may delay it further.
     */
    private synchronized void delayWhenStable(InternalGenerator generator, int writeGuardTime) {
        ScheduledFuture<?> scheduledFuture = futureGeneration.get(generator);
        if (scheduledFuture != null) {
            if (scheduledFuture.getDelay(TimeUnit.MILLISECONDS) < writeGuardTime) {
                scheduledFuture.cancel(false);
            } else {
                return;
            }
        }
        Runnable command = () -> {
            try {
                generator.generate();
                futureGeneration.remove(generator);
            } catch (IOException | TemplateException e) {
                logger.warn("Cannot create helper class file in library directory", e);
            }
        };
        int computedDelay = writeGuardTime;
        // Minimal delay if the file doesn't exist, we can write it
        Path path = sourceWriter.getPath(getGeneratedPackageName(), generator.generatedFileName());
        if (!path.toFile().exists()) {
            computedDelay = 1000;
        }
        logger.debug("Scheduling {} generation in {} ms", generator.generatedFileName(), computedDelay);
        futureGeneration.put(generator, scheduledPool.schedule(command, computedDelay, TimeUnit.MILLISECONDS));
    }

    public void generateActions(int guardTime) {
        delayWhenStable(actionGeneration, guardTime);
    }

    public void generateItems(int guardTime) {
        delayWhenStable(itemGeneration, guardTime);
    }

    public void generateThings(int guardTime) {
        delayWhenStable(thingGeneration, guardTime);
    }

    public void generateJava223Script() {
        String packageName = getGeneratedPackageName();

        try {
            Template template = cfg.getTemplate(TPL_LOCATION + "Java223Script.ftl");
            Map<String, Object> context = new HashMap<>();
            context.put("AUTOGENERATED_WARNING", AUTOGENERATED_WARNING);
            context.put("packageName", packageName);
            context.put("imports", injectedCodeGenerator.getDefaultPresetImportListForSuperClass());
            context.put("fieldsDeclaration", injectedCodeGenerator.getInjectedFieldsDeclaration());

            StringWriter writer = new StringWriter();
            template.process(context, writer);

            sourceWriter.replaceHelperFileIfNotEqual(packageName, "Java223Script", writer.toString());
        } catch (IOException | TemplateException e) {
            logger.warn("Cannot create helper class Java223Script in library directory", e);
        }
    }

    /**
     * Generate a class with all Enum, as static Strings (useful for place where only static code is allowed, such
     * as annotation value).
     */
    public void generateEnumStrings() {
        String packageName = getGeneratedPackageName();
        try {
            Template template = cfg.getTemplate(TPL_LOCATION + "EnumStrings.ftl");
            Map<String, Object> context = new HashMap<>();
            context.put("AUTOGENERATED_WARNING", AUTOGENERATED_WARNING);
            context.put("packageName", packageName);
            context.put("enumsByType", injectedCodeGenerator.getEnumByType());

            StringWriter writer = new StringWriter();
            template.process(context, writer);

            sourceWriter.replaceHelperFileIfNotEqual(packageName, "EnumStrings", writer.toString());
        } catch (IOException | TemplateException e) {
            logger.warn("Cannot create helper class EnumStrings in library directory", e);
        }
    }

    @Nullable
    private Void internalGenerateActions() throws IOException, TemplateException {
        logger.debug("Generating actions");
        List<ThingActions> thingActions;
        Collection<ActionType> actions = moduleTypeRegistry.getActions();
        try {
            Set<Class<?>> classes = new HashSet<>();
            thingActions = bundleContext.getServiceReferences(ThingActions.class, null).stream()
                    .map(bundleContext::getService).filter(sr -> classes.add(sr.getClass())).toList();
        } catch (InvalidSyntaxException e) {
            logger.warn("Failed to get thing actions: {}", e.getMessage());
            return null;
        } catch (IllegalStateException e) {
            logger.warn(
                    "Failed to get bundle reference: {}. May happen when openHAB is stopping. Abort generating actions",
                    e.getMessage());
            return null;
        }

        Template templateAction = cfg.getTemplate(TPL_LOCATION + "ThingAction.ftl");
        Map<String, Set<String>> actionsByScope = new HashMap<>();
        Set<String> allClassesToImport = new HashSet<>();

        // keep track of newly generated actions files
        Set<Path> newlyGeneratedThingActionsFiles = new HashSet<>();

        for (ThingActions thingAction : thingActions) {
            Class<? extends ThingActions> clazz = thingAction.getClass();

            ThingActionsScope scopeAnnotation = clazz.getAnnotation(ThingActionsScope.class);
            if (scopeAnnotation == null) {
                continue;
            }
            String scope = scopeAnnotation.name();
            String simpleClassName = clazz.getSimpleName();
            String packageName = SourceWriter.getPackageName(GENERATED, scope);
            Set<String> strings = actionsByScope.computeIfAbsent(scope, (key -> new HashSet<>()));
            if (strings != null) { // never null but check thinks so
                strings.add(packageName + "." + simpleClassName);
            }

            logger.trace("Processing class '{}' in package '{}'", simpleClassName, clazz.getPackageName());

            List<Method> methods = Arrays.stream(clazz.getDeclaredMethods())
                    .filter(method -> method.getDeclaredAnnotation(RuleAction.class) != null).toList();

            Set<String> classesToImport = new HashSet<>();
            List<MethodDTO> methodsDTO = new ArrayList<>();

            for (Method method : methods) {
                String name = method.getName();
                String returnValue = parseArgumentType(method.getGenericReturnType(), classesToImport);
                ActionType actionType = findActionType(actions, scope, name);

                List<ParameterDTO> parameters = mergeParameterInfos(method, actionType, classesToImport);

                List<Output> outputs = actionType == null ? Collections.emptyList() : actionType.getOutputs();
                String description = actionType == null ? "" : safe(actionType.getDescription());
                MethodDTO methodDTO = new MethodDTO(returnValue, outputs, name, description, parameters);
                logger.trace("Found method '{}' with parameters '{}' and return value '{}'.", name, parameters,
                        returnValue);

                methodsDTO.add(methodDTO);
            }

            allClassesToImport.addAll(classesToImport);

            Map<String, Object> context = new HashMap<>();
            context.put("AUTOGENERATED_WARNING", AUTOGENERATED_WARNING);
            context.put("packageName", packageName);
            context.put("scope", scope);
            context.put("classesToImport", classesToImport);
            context.put("simpleClassName", simpleClassName);
            context.put("methods", methodsDTO);

            StringWriter writer = new StringWriter();
            templateAction.process(context, writer);

            sourceWriter.replaceHelperFileIfNotEqual(packageName, simpleClassName, writer.toString());
            newlyGeneratedThingActionsFiles.add(sourceWriter.getPath(packageName, simpleClassName));
        }

        // adding classes to the lib of exported dependencies
        dependencyGenerator.setClassesToAddToDependenciesLib(allClassesToImport);

        // now generate action factory :
        Template templateActionFactory = cfg.getTemplate(TPL_LOCATION + "Actions.ftl");
        Map<String, Object> context = new HashMap<>();
        context.put("AUTOGENERATED_WARNING", AUTOGENERATED_WARNING);
        context.put("packageName", SourceWriter.getPackageName(GENERATED));
        context.put("classesToImport", actionsByScope.values().stream().flatMap(Collection::stream).toList());
        // we add a method to the context for the template to use. This method returns the class name of a fully
        // qualified class
        @SuppressWarnings("unchecked")
        TemplateMethodModelEx tmmLastName = (
                args) -> className(((List<freemarker.template.SimpleScalar>) args).getFirst().getAsString()).orElse("");
        context.put("lastName", tmmLastName);
        // we add a method to the context for the template to use. This method capitalizes the first letter of a string
        @SuppressWarnings("unchecked")
        TemplateMethodModelEx tmmCapitalize = (args) -> capitalize(
                ((List<freemarker.template.SimpleScalar>) args).getFirst().getAsString());
        context.put("camelCase", tmmCapitalize);
        context.put("actionsByScope", actionsByScope);
        StringWriter writer = new StringWriter();
        templateActionFactory.process(context, writer);

        sourceWriter.replaceHelperFileIfNotEqual(SourceWriter.getPackageName(GENERATED), "Actions", writer.toString());

        // delete old files (those that we didn't generate)
        cleanOldGeneratedThingActionsFiles(newlyGeneratedThingActionsFiles);

        return null;
    }

    private @Nullable ActionType findActionType(Collection<ActionType> actions, String scope, String name) {
        for (ActionType actionType : actions) {
            String shouldStartWith = scope + "." + name + "#";
            if (actionType.getUID().startsWith(shouldStartWith)) {
                return actionType;
            }
        }
        return null;
    }

    /**
     * Build parameters DTO for method generation
     * 
     * @param method The method to inspect
     * @param actionType The action, found in the module registry
     * @param classesToImport This method will add to this set all classes to import in the generated code.
     * @return All parameters in a convenient DTO format
     */
    private List<ParameterDTO> mergeParameterInfos(Method method, @Nullable ActionType actionType,
            Set<String> classesToImport) {
        List<String> parametersType = Arrays.stream(method.getGenericParameterTypes())
                .map(pt -> parseArgumentType(pt, classesToImport)).toList();
        List<String> parametersClass = Arrays.stream(method.getParameterTypes())
                .map(pt -> parseArgumentType(pt, classesToImport)).toList();

        if (parametersType.size() != parametersClass.size()) {
            throw new IllegalArgumentException(
                    "The number of parameters type and class doesn't match. Shouldn't happen. Method: "
                            + method.getName());
        }

        List<ParameterDTO> parameters = new ArrayList<>(parametersType.size());
        for (int i = 0; i < parametersType.size(); i++) {
            String name = null;
            String description = null;
            if (actionType != null) {
                try {
                    name = actionType.getInputs().get(i).getName();
                    description = actionType.getInputs().get(i).getDescription();
                } catch (IndexOutOfBoundsException e) {
                    logger.warn(
                            "Inputs found in module registry and real Action class doesn't have the same parameter number!");
                }
            }
            parameters.add(
                    new ParameterDTO(parametersType.get(i), parametersClass.get(i), safe(name), safe(description)));
        }

        return parameters;
    }

    private String safe(@Nullable String s) {
        return s == null ? "" : s;
    }

    /**
     * Safely delete all generated files (file starting with the AUTOGENERATED warning)
     * Will delete empty dir as well.
     * 
     * @param directory The directory to clean
     * @throws IOException If we cannot read or delete files
     */
    public void cleanGeneratedFiles(Path directory) throws IOException {
        if (Files.exists(directory)) {
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(directory)) {
                for (Path path : stream) {
                    if (Files.isDirectory(path)) {
                        cleanGeneratedFiles(path);
                        deleteDirIfEmpty(path);
                    } else {
                        if (isAJavaGeneratedFile(path) && Files.isWritable(path)) {
                            Files.delete(path);
                        }
                    }
                }
            }
            deleteDirIfEmpty(directory);
        }
    }

    private void cleanOldGeneratedThingActionsFiles(Set<Path> newlyGeneratedThingActionsFiles) throws IOException {
        // scan the generated directory and delete old files if they aren't in the list of newly generated ones
        try (DirectoryStream<Path> streamDir = Files
                .newDirectoryStream(sourceWriter.getHelperPath().resolve(GENERATED))) {
            for (Path path : streamDir) {
                if (Files.isDirectory(path)) {
                    try (DirectoryStream<Path> streamFiles = Files.newDirectoryStream(path)) {
                        for (Path file : streamFiles) {
                            if (isAJavaGeneratedFile(file)) {
                                if (!newlyGeneratedThingActionsFiles.contains(file)) {
                                    logger.debug("Deleting old generated file {}", file);
                                    Files.delete(file);
                                }
                            }
                        }
                    }
                    SourceGenerator.deleteDirIfEmpty(path);
                }
            }
        }
    }

    /**
     * Return a user-friendly short readable name (without package details) and add the relevant full class name to the
     * import list
     *
     * @param type The type to consider
     * @param imports A set to add imports into
     * @return a user-friendly printable name (without full package)
     */
    protected static String parseArgumentType(Type type, Set<String> imports) {
        String typeName = type.getTypeName();
        String currentName = "";
        StringBuilder friendlyFullType = new StringBuilder();
        for (int i = 0; i < typeName.length(); i++) {
            char ch = typeName.charAt(i);
            boolean isAOKClassCharacter = Character.isLetter(ch) || Character.isDigit(ch)
                    || Character.valueOf(ch).equals('_') || Character.valueOf(ch).equals('.');
            if (isAOKClassCharacter) {
                currentName += ch;
            }
            if (!isAOKClassCharacter || i == typeName.length() - 1) {
                if (!currentName.isEmpty()) {
                    Optional<String> classNameOfAPackage = className(currentName);
                    if (classNameOfAPackage.isPresent()) {
                        imports.add(currentName);
                        friendlyFullType.append(classNameOfAPackage.get());
                    } else {
                        friendlyFullType.append(currentName);
                    }
                }
                if (!isAOKClassCharacter) {
                    friendlyFullType.append(ch);
                }
                currentName = "";
            }
        }
        return friendlyFullType.toString();
    }

    @Nullable
    private Void internalGenerateItems() throws IOException, TemplateException {
        logger.debug("Generating items");
        Collection<Item> items = itemRegistry.getItems();
        String packageName = getGeneratedPackageName();

        Template template = cfg.getTemplate(TPL_LOCATION + "Items.ftl");
        Map<String, Object> context = new HashMap<>();
        context.put("AUTOGENERATED_WARNING", AUTOGENERATED_WARNING);
        context.put("packageName", packageName);
        context.put("items", items);
        context.put("itemImports",
                items.stream().map(item -> item.getClass().getCanonicalName()).collect(Collectors.toSet()));

        StringWriter writer = new StringWriter();
        template.process(context, writer);

        sourceWriter.replaceHelperFileIfNotEqual(packageName, "Items", writer.toString());
        return null;
    }

    public static String getGeneratedPackageName() {
        return SourceWriter.getPackageName(GENERATED);
    }

    @Nullable
    private Void internalGenerateThings() throws IOException, TemplateException {
        logger.debug("Generating things");
        Collection<Thing> things = thingRegistry.getAll();
        String packageName = getGeneratedPackageName();

        Template template = cfg.getTemplate(TPL_LOCATION + "Things.ftl");
        Map<String, Object> context = new HashMap<>();
        context.put("AUTOGENERATED_WARNING", AUTOGENERATED_WARNING);
        context.put("packageName", packageName);
        context.put("things", things);

        @SuppressWarnings("unchecked")
        TemplateMethodModelEx tmm = (args) -> escapeName(
                ((List<freemarker.ext.beans.StringModel>) args).getFirst().getWrappedObject().toString());
        context.put("escapeName", tmm);

        StringWriter writer = new StringWriter();
        template.process(context, writer);

        sourceWriter.replaceHelperFileIfNotEqual(packageName, "Things", writer.toString());
        return null;
    }

    private static String capitalize(String minusString) {
        return minusString.substring(0, 1).toUpperCase() + minusString.substring(1);
    }

    private static String escapeName(String textToEscape) {
        return textToEscape.replace(":", "_").replace("-", "_");
    }

    private static Optional<String> className(String fullName) {
        int lastDotIndex = fullName.lastIndexOf('.');
        return lastDotIndex == -1 ? Optional.empty() : Optional.of(fullName.substring(lastDotIndex + 1));
    }

    public record MethodDTO(String returnValueType, List<Output> outputs, String name, String description,
            List<ParameterDTO> parameters) {
    }

    public record ParameterDTO(String type, String nonGenericType, String name, String description) {
    }

    public record InternalGenerator(Callable<@Nullable Void> generator, String generatedFileName) {
        void generate() throws IOException, TemplateException {
            try {
                generator.call();
            } catch (IOException | TemplateException e) {
                throw e;
            } catch (Exception e) { // wrap all other exceptions in IOException
                throw new IOException("Cannot generate " + generatedFileName, e);
            }
        }
    }
}
