/*
 * Copyright (c) 2010-2026 Contributors to the openHAB project
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.openhab.io.yamlcomposer.internal;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Set;

import org.eclipse.jdt.annotation.NonNullByDefault;
import org.eclipse.jdt.annotation.Nullable;
import org.openhab.core.service.WatchService;
import org.openhab.core.service.WatchService.Kind;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Watches OPENHAB_CONF/yamlcomposer and writes composed YAML files to OPENHAB_CONF/yaml/composed.
 *
 * @author Jimmy Tanagra - Initial contribution
 */
@NonNullByDefault
@Component(immediate = true, service = YamlComposerWatchService.class)
public class YamlComposerWatchService implements WatchService.WatchEventListener {
    private static final Path WATCHED_SOURCE_PATH = ComposerConfig.SOURCE_ROOT_DIRECTORY;

    private static final String OUTPUT_ROOT_README = """
            This directory contains YAML files generated by the YAML Composer add-on.
            Do not edit these files manually, as they will be overwritten by the composer.
            Instead, edit the source YAML files in the 'yamlcomposer' directory and let the composer generate the output here.
            """;

    private final Logger logger = LoggerFactory.getLogger(YamlComposerWatchService.class);
    private final IncludeRegistry includeRegistry = new IncludeRegistry();
    private final WatchService watchService;

    @Activate
    public YamlComposerWatchService(@Reference(target = WatchService.CONFIG_WATCHER_FILTER) WatchService watchService) {
        this.watchService = watchService;

        try {
            Files.createDirectories(ComposerConfig.sourceRoot());
            Path outputRoot = ComposerConfig.outputRoot();
            if (!outputRoot.toFile().exists()) {
                Files.createDirectories(outputRoot);
                Files.writeString(outputRoot.resolve("readme.txt"), OUTPUT_ROOT_README, StandardCharsets.UTF_8);
            }
            processDirectory(ComposerConfig.sourceRoot());
        } catch (IOException e) {
            logger.warn("Cannot prepare yaml composer directories: {}", e.getMessage());
        }

        watchService.registerListener(this, WATCHED_SOURCE_PATH);
    }

    @Deactivate
    public void deactivate() {
        watchService.unregisterListener(this);
        includeRegistry.clear();
    }

    @Override
    public synchronized void processWatchEvent(Kind kind, Path fullPath) {
        Path sourcePath = fullPath;
        if (Files.isDirectory(sourcePath) || !Files.isReadable(sourcePath)) {
            return;
        }

        if (includeRegistry.hasInclude(sourcePath)) {
            Set<Path> dependingMains = includeRegistry.getMainsForInclude(sourcePath);
            dependingMains.forEach(mainFilePath -> processWatchEvent(Kind.MODIFY, mainFilePath));
            return;
        }

        String fileName = sourcePath.getFileName().toString();
        if (!YamlComposer.isYamlFile(fileName) || YamlComposer.isIncludeFile(fileName)) {
            return;
        }

        includeRegistry.removeMain(sourcePath);

        Path outputPath = ComposerConfig.resolveOutputPath(sourcePath);
        Path relativeSourcePath = ComposerConfig.configRoot().relativize(sourcePath);
        Path relativeOutputPath = ComposerConfig.configRoot().relativize(outputPath);
        if (kind == Kind.DELETE) {
            try {
                Files.deleteIfExists(outputPath);
                logger.info("YAML Composer: DELETED generated file '{}'", relativeOutputPath);
            } catch (IOException e) {
                logger.warn("YAML Composer: failed to delete generated file '{}': {}", relativeOutputPath,
                        e.getMessage());
            }
            return;
        }

        try {
            Object yamlObject = YamlComposer.load(sourcePath,
                    includePath -> includeRegistry.registerInclude(sourcePath, includePath));
            if (yamlObject == null) {
                logger.warn("YAML Composer produced no output when processing '{}'", relativeSourcePath);
                return;
            }

            ComposerUtils.writeCompiledOutput(yamlObject, sourcePath);
            logger.info("YAML Composer: {} -> {}", relativeSourcePath, relativeOutputPath);
        } catch (IOException e) {
            logger.warn("YAML Composer failed to process '{}': {}", relativeSourcePath, e.getMessage());
        }
    }

    private void processDirectory(Path sourceDirectory) {
        try {
            Files.walkFileTree(sourceDirectory, new SimpleFileVisitor<>() {
                @Override
                public FileVisitResult visitFile(@Nullable Path sourcePath, @Nullable BasicFileAttributes attrs)
                        throws IOException {
                    if (sourcePath != null && attrs != null && attrs.isRegularFile()) {
                        Path outputPath = ComposerConfig.resolveOutputPath(sourcePath);
                        if (Files.exists(outputPath)) {
                            try {
                                long outputMtime = Files.getLastModifiedTime(outputPath).toMillis();
                                long sourceMtime = Files.getLastModifiedTime(sourcePath).toMillis();
                                if (outputMtime > sourceMtime) {
                                    return FileVisitResult.CONTINUE;
                                }
                            } catch (IOException e) {
                                logger.debug("Failed to compare mtime for '{}' and '{}': {}", outputPath, sourcePath,
                                        e.getMessage());
                            }
                        }

                        processWatchEvent(Kind.CREATE, sourcePath);
                    }
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult visitFileFailed(@Nullable Path sourcePath, @Nullable IOException exc)
                        throws IOException {
                    if (sourcePath != null && exc != null) {
                        Path relativeSourcePath = ComposerConfig.configRoot().relativize(sourcePath);
                        logger.warn("Failed to process {}: {}", relativeSourcePath, exc.getMessage());
                    }
                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            logger.warn("Could not list YAML source files in '{}': {}", sourceDirectory, e.getMessage());
        }
    }
}
