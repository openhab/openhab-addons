/*
 * Copyright (c) 2010-2025 Contributors to the openHAB project
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */

// AUTO-GENERATED, DO NOT EDIT!

package org.openhab.binding.matter.internal.client.dto.cluster.gen;

import java.math.BigInteger;
import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.jdt.annotation.NonNull;
import org.openhab.binding.matter.internal.client.dto.cluster.ClusterCommand;

/**
 * BridgedDeviceBasicInformation
 *
 * @author Dan Cunningham - Initial contribution
 */
public class BridgedDeviceBasicInformationCluster extends BasicInformationCluster {

    public static final int CLUSTER_ID = 0x0039;
    public static final String CLUSTER_NAME = "BridgedDeviceBasicInformation";
    public static final String CLUSTER_PREFIX = "bridgedDeviceBasicInformation";
    public static final String ATTRIBUTE_FEATURE_MAP = "featureMap";

    public FeatureMap featureMap; // 65532 FeatureMap
    // Structs

    public class StartUp {
        public StartUp() {
        }
    }

    public class ShutDown {
        public ShutDown() {
        }
    }

    /**
     * The Leave event SHOULD be generated by the bridge when it detects that the associated device has left the
     * non-Matter network.
     * &gt; [!NOTE]
     * &gt; The FabricIndex field has the X conformance, indicating it shall NOT be present. This event, in the context
     * of Bridged Device Basic Information cluster, has no usable fields, but the original Basic Information cluster’s
     * field definition is kept for completeness.
     */
    public class Leave {
        public String fabricIndex; //

        public Leave(String fabricIndex) {
            this.fabricIndex = fabricIndex;
        }
    }

    /**
     * This event shall be generated when there is a change in the Reachable attribute. Its purpose is to provide an
     * indication towards interested parties that the reachability of a bridged device has changed over its native
     * connectivity technology, so they may take appropriate action.
     * After (re)start of a bridge this event may be generated.
     */
    public class ReachableChanged {
        public ReachableChanged() {
        }
    }

    /**
     * This event (when supported) shall be generated the next time a bridged device becomes active after a KeepActive
     * command is received.
     * See KeepActive for more details.
     */
    public class ActiveChanged {
        /**
         * This field shall indicate the minimum duration, in milliseconds, that the bridged device will remain active
         * after receiving the initial request from the KeepActive processing steps.
         * If the bridged device is a Matter Intermittently Connected Device, PromisedActiveDuration shall be set to the
         * PromisedActiveDuration value returned in the StayActiveResponse command.
         * If the bridged device is not a Matter Intermittently Connected Device, the implementation of this is
         * best-effort since it may interact with non-native protocol.
         */
        public Integer promisedActiveDuration; // uint32

        public ActiveChanged(Integer promisedActiveDuration) {
            this.promisedActiveDuration = promisedActiveDuration;
        }
    }

    // Bitmaps
    public static class FeatureMap {
        /**
         * 
         * Support bridged ICDs.
         */
        public boolean bridgedIcdSupport;

        public FeatureMap(boolean bridgedIcdSupport) {
            this.bridgedIcdSupport = bridgedIcdSupport;
        }
    }

    public BridgedDeviceBasicInformationCluster(BigInteger nodeId, int endpointId) {
        super(nodeId, endpointId, 57, "BridgedDeviceBasicInformation");
    }

    protected BridgedDeviceBasicInformationCluster(BigInteger nodeId, int endpointId, int clusterId,
            String clusterName) {
        super(nodeId, endpointId, clusterId, clusterName);
    }

    // commands
    /**
     * Upon receipt, the server shall attempt to keep the bridged device active for the duration specified by the
     * command, when the device is next active.
     * The implementation of this is best-effort since it may interact with non-native protocols. However, several
     * specific protocol requirements are:
     * • If the bridged device is a Matter Intermittently Connected Device, then the server shall send a
     * StayActiveRequest command with the StayActiveDuration field set to value of the StayActiveDuration field in the
     * received command to the bridged device when the bridged device next sends a checks-in message or subscription
     * report. See Intermittently Connected Devices Behavior for details on ICD state management.
     * When the bridge detects that the bridged device goes into an active state, an ActiveChanged event shall be
     * generated.
     * In order to avoid unnecessary power consumption in the bridged device:
     * • The server shall enter a &quot;pending active&quot; state for the associated device when the KeepActive command
     * is received. The server &quot;pending active&quot; state shall expire after the amount of time defined by the
     * TimeoutMs field, in milliseconds, if no subsequent KeepActive command is received. When a KeepActive command is
     * received, the &quot;pending active&quot; state is set, the StayActiveDuration is updated to the greater of the
     * new value and the previously stored value, and the TimeoutMs is updated to the greater of the new value and the
     * remaining time until the prior &quot;pending active&quot; state expires.
     * • The server shall only keep the bridged device active once for a request. (The server shall only consider the
     * operation performed if an associated ActiveChanged event was generated.)
     */
    public static ClusterCommand keepActive(Integer stayActiveDuration, Integer timeoutMs) {
        Map<String, Object> map = new LinkedHashMap<>();
        if (stayActiveDuration != null) {
            map.put("stayActiveDuration", stayActiveDuration);
        }
        if (timeoutMs != null) {
            map.put("timeoutMs", timeoutMs);
        }
        return new ClusterCommand("keepActive", map);
    }

    @Override
    public @NonNull String toString() {
        String str = "";
        str += "featureMap : " + featureMap + "\n";
        return str;
    }
}
