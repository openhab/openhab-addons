// ThreadsafeTimers is injected into the JS runtime
// The default identifier of the script has to be computed on script executon, as it is not available at the time of script compilation

(function (global) {
  'use strict';

  // Append the script file name OR rule UID depending on which is available
  const System = Java.type('java.lang.System');
  const formatRegExp = /%[sdj%]/g;

  /**
   * Gets the default identifier of the script.
   * @returns {string}
   */
  function getDefaultIdentifier () {
    return 'org.openhab.automation.script' + (globalThis['javax.script.filename'] ? '.file.' + globalThis['javax.script.filename'].replace(/^.*[\\\/]/, '') : globalThis.ruleUID ? '.ui.' + globalThis.ruleUID : '');
  }

  /**
   * Gets a logger instance for given name.
   * @param {string} [name] optional logger name, defaults to the default identifier of the script (see {@link getDefaultIdentifier})
   * @returns {*} logger instance
   */
  function getLogger (name) {
    if (typeof name === 'string') {
      log = Java.type('org.slf4j.LoggerFactory').getLogger(name);
    }
    if (log === null) {
      log = Java.type('org.slf4j.LoggerFactory').getLogger(getDefaultIdentifier());
    }
    return log;
  }

  let log = null;

  function stringify (value) {
    try {
      if (typeof value === 'string') return value;
      // special cases
      if (value === undefined) {
        return 'undefined';
      }
      if (value === null) {
        return 'null';
      }
      // JSON.stringify all objects that do not polyfill toString()
      const str = value.toString();
      if (typeof value === 'object' && (str === '[object Object]' || str === '[object Java]')) {
        return JSON.stringify(value, null, 2);
      }
      return str;
    } catch (e) {
      return 'Error: failed to format log message: ' + e;
    }
  }

  function format (f) {
    try {
      const args = arguments;

      // If there is only one argument, stringify and return it
      if (args.length === 1) return stringify(f);

      // Else if the first arg is string, do regex string formatting
      // the number of args after the formatted string must match the number of % placeholder
      let str;
      let i = 1;
      if (typeof f === 'string') {
        str = String(f).replace(formatRegExp, function (x) {
          if (x === '%%') return '%';
          if (i >= args.length) return x;
          switch (x) {
            case '%s': return String(args[i++]);
            case '%d': return Number(args[i++]);
            case '%j':
              try {
                return stringify(args[i++]);
              } catch (e) {
                return '[Circular]';
              }
              // falls through
            default:
              return x;
          }
        });
      }
      // Else stringify and join all args
      for (let x = args[i]; i < args.length; x = args[++i]) {
        str += ' ' + stringify(x);
      }
      return str;
    } catch (e) {
      return 'Error: failed to format log message: ' + e;
    }
  }

  const counters = {};
  const timers = {};

  // Polyfills for common NodeJS functions

  const console = {
    assert: function (expression, message) {
      if (!expression) {
        getLogger().error(message);
      }
    },

    count: function (label) {
      let counter;

      if (label) {
        if (counters.hasOwnProperty(label)) {
          counter = counters[label];
        } else {
          counter = 0;
        }

        // update
        counters[label] = ++counter;
        getLogger().debug(format.apply(null, [label + ':', counter]));
      }
    },

    debug: function () {
      getLogger().debug(format.apply(null, arguments));
    },

    info: function () {
      getLogger().info(format.apply(null, arguments));
    },

    log: function () {
      getLogger().info(format.apply(null, arguments));
    },

    warn: function () {
      getLogger().warn(format.apply(null, arguments));
    },

    error: function () {
      getLogger().error(format.apply(null, arguments));
    },

    trace: function () {
      getLogger().trace(new Error(format.apply(null, arguments)).stack.replace(/^Error: /, ''));
    },

    time: function (label) {
      if (label) {
        timers[label] = System.currentTimeMillis();
      }
    },

    timeEnd: function (label) {
      if (label) {
        const now = System.currentTimeMillis();
        if (timers.hasOwnProperty(label)) {
          getLogger().info(format.apply(null, [label + ':', (now - timers[label]) + 'ms']));
          delete timers[label];
        } else {
          getLogger().info(format.apply(null, [label + ':', '<no timer>']));
        }
      }
    },

    // Allow user customizable logging names
    // Be aware that a log4j2 required a logger defined for the logger name, otherwise messages won't be logged!
    set loggerName (name) {
      getLogger(name);
      this._loggerName = name;
      ThreadsafeTimers.setIdentifier(name);
    },

    get loggerName () {
      return this._loggerName || getDefaultIdentifier();
    }
  };

  // Polyfill common NodeJS functions onto the global object
  globalThis.console = console;
  globalThis.setTimeout = function (functionRef, delay, ...args) {
    ThreadsafeTimers.setIdentifier(console.loggerName);
    return ThreadsafeTimers.setTimeout(() => functionRef(...args), delay);
  };
  globalThis.clearTimeout = ThreadsafeTimers.clearTimeout;
  globalThis.setInterval = function (functionRef, delay, ...args) {
    ThreadsafeTimers.setIdentifier(console.loggerName);
    return ThreadsafeTimers.setInterval(() => functionRef(...args), delay);
  };
  globalThis.clearInterval = ThreadsafeTimers.clearInterval;

  // Support legacy NodeJS libraries
  globalThis.global = globalThis;
  globalThis.process = { env: { NODE_ENV: '' } };
})(this);
